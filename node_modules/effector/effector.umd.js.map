{"version":3,"file":"effector.umd.js","sources":["../../src/effector/collection.ts","../../src/effector/throw.ts","../../src/effector/region.ts","../../src/effector/createNode.ts","../../src/effector/kernel.ts","../../src/effector/naming.ts","../../src/effector/config.ts","../../src/effector/template.ts","../../src/effector/createUnit.ts","../../src/effector/tag.ts","../../src/effector/combine.ts","../../src/effector/defer.ts","../../src/effector/createEffect.ts","../../src/effector/merge.ts","../../src/effector/sample.ts","../../src/effector/fork/util.ts","../../src/effector/observable.ts","../../src/effector/validate.ts","../../src/effector/getter.ts","../../src/effector/id.ts","../../src/effector/own.ts","../../src/effector/is.ts","../../src/effector/caller.ts","../../src/effector/step.ts","../../src/effector/stateRef.ts","../../src/effector/clearNode.ts","../../src/effector/subscription.ts","../../src/effector/forward.ts","../../src/effector/watch.ts","../../src/effector/split.ts","../../src/effector/fork/allSettled.ts","../../src/effector/attach.ts","../../src/effector/createApi.ts","../../src/effector/createDomain.ts","../../src/effector/fork/fork.ts","../../src/effector/fork/createScope.ts","../../src/effector/fromObservable.ts","../../src/effector/guard.ts","../../src/effector/fork/hydrate.ts","../../src/effector/restore.ts","../../src/effector/fork/scopeBind.ts","../../src/effector/fork/serialize.ts"],"sourcesContent":["export function forIn<T>(\n  obj: Record<string, T>,\n  cb: (value: T, key: string) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key)\n  }\n}\n\nexport const includes = <T>(list: T[], item: T) => list.includes(item)\n\nexport const removeItem = <T>(list: T[], item: T) => {\n  const pos = list.indexOf(item)\n  if (pos !== -1) {\n    list.splice(pos, 1)\n  }\n}\n\nexport const add = <T>(list: T[], item: T) => list.push(item)\n\nexport function forEach<T>(\n  list: T[],\n  fn: (item: T, index: number, list: T[]) => void,\n): void\nexport function forEach<K, T>(\n  list: Map<K, T>,\n  fn: (item: T, key: K) => void,\n): void\nexport function forEach<T>(list: Set<T>, fn: (item: T) => void): void\nexport function forEach(list, fn: Function) {\n  list.forEach(fn)\n}\n","export function assert(condition: unknown, message: string): asserts condition {\n  if (!condition) throw Error(message)\n}\n\nexport const deprecate = (\n  condition: unknown,\n  subject: string,\n  suggestion?: string,\n) =>\n  !condition &&\n  console.error(\n    `${subject} is deprecated${\n      suggestion ? `, use ${suggestion} instead` : ''\n    }`,\n  )\n","import {getParent, getMeta} from './getter'\nimport {createNode} from './createNode'\nimport type {Template} from '../forest/index.h'\n\ntype RegionStack = {\n  parent: RegionStack | null\n  value\n  template\n  sidRoot?: string\n}\n\nexport let regionStack: RegionStack | null = null\n\nexport const readTemplate = (): Template | null =>\n  regionStack && regionStack.template\nexport const readSidRoot = (sid?: string | null) => {\n  if (sid && regionStack && regionStack.sidRoot)\n    sid = `${regionStack.sidRoot}|${sid}`\n  return sid\n}\n\nexport function withRegion(unit, cb: () => void) {\n  regionStack = {\n    parent: regionStack,\n    value: unit,\n    template: getMeta(unit, 'template') || readTemplate(),\n    sidRoot: getMeta(unit, 'sidRoot') || (regionStack && regionStack.sidRoot),\n  }\n  try {\n    return cb()\n  } finally {\n    regionStack = getParent(regionStack)\n  }\n}\n\nexport const withFactory = ({\n  sid,\n  name,\n  loc,\n  method,\n  fn,\n}: {\n  sid: string\n  name?: string\n  loc?\n  method?: string\n  fn: () => any\n}) => {\n  const sidNode = createNode({\n    meta: {sidRoot: readSidRoot(sid), name, loc, method},\n  })\n  return withRegion(sidNode, fn)\n}\n","import type {Node, NodeUnit, Cmd} from './index.h'\nimport {getGraph, getOwners, getLinks, getValue} from './getter'\nimport {nextNodeID} from './id'\nimport {CROSSLINK} from './tag'\nimport {regionStack} from './region'\nimport {own} from './own'\nimport {add, forEach} from './collection'\n\nexport const arrifyNodes = (\n  list: NodeUnit | Array<NodeUnit | NodeUnit[]> = [],\n): Node[] => (Array.isArray(list) ? list : [list]).flat().map(getGraph)\n\nexport function createNode({\n  node = [],\n  from,\n  source,\n  parent = from || source,\n  to,\n  target,\n  child = to || target,\n  scope = {},\n  meta = {},\n  family: familyRaw = {type: 'regular'},\n  regional,\n}: {\n  node?: Array<Cmd | false | void | null>\n  from?: NodeUnit | NodeUnit[]\n  source?: NodeUnit | NodeUnit[]\n  parent?: NodeUnit | NodeUnit[]\n  to?: NodeUnit | NodeUnit[]\n  target?: NodeUnit | NodeUnit[]\n  child?: NodeUnit | NodeUnit[]\n  scope?: {[name: string]}\n  meta?: {[name: string]}\n  family?: {\n    type?: 'regular' | 'crosslink' | 'domain'\n    links?: NodeUnit | NodeUnit[]\n    owners?: NodeUnit | Array<NodeUnit | NodeUnit[]>\n  }\n  regional?: boolean\n} = {}): Node {\n  const sources = arrifyNodes(parent)\n  const links = arrifyNodes(familyRaw.links)\n  const owners = arrifyNodes(familyRaw.owners)\n  const seq: Cmd[] = []\n  forEach(node, item => item && add(seq, item))\n  const result: Node = {\n    id: nextNodeID(),\n    seq,\n    next: arrifyNodes(child),\n    meta,\n    scope,\n    family: {\n      type: familyRaw.type || CROSSLINK,\n      links,\n      owners,\n    },\n  }\n  forEach(links, link => add(getOwners(link), result))\n  forEach(owners, owner => add(getLinks(owner), result))\n  forEach(sources, source => add(source.next, result))\n  if (regional && regionStack) {\n    own(getValue(regionStack), [result])\n  }\n  return result\n}\n","import type {Leaf} from '../forest/index.h'\n\nimport type {Node, NodeUnit, StateRef} from './index.h'\nimport {readRef} from './stateRef'\nimport {getForkPage, getGraph, getMeta, getParent, getValue} from './getter'\nimport {STORE, EFFECT, SAMPLER, STACK, BARRIER, VALUE, REG_A, MAP} from './tag'\nimport type {Scope} from './unit.h'\nimport {add, forEach} from './collection'\n\n/** Names of priority groups */\ntype PriorityTag = 'child' | 'pure' | 'read' | 'barrier' | 'sampler' | 'effect'\n\nexport type BarrierPriorityTag = 'read' | 'barrier' | 'sampler' | 'effect'\n\n/**\n * Position in the current branch,\n * including call stack, priority type\n * and index of next step in the executed Node\n */\ntype Layer = {\n  idx: number\n  stack: Stack\n  type: PriorityTag\n  id: number\n}\n\n/** Call stack */\nexport type Stack = {\n  value\n  a\n  b\n  c?\n  parent: Stack | null\n  node: Node\n  page: Leaf | null\n  scope?: Scope | null | void\n}\n\n/** Queue as linked list or skew heap */\ntype QueueItem = {\n  /** node value */\n  v: Layer\n  /** left node. always null in queue but used in skew heap */\n  l: QueueItem | null\n  /** right node */\n  r: QueueItem | null\n}\ntype QueueBucket = {\n  first: QueueItem | null\n  last: QueueItem | null\n  size: number\n}\n\n/** Dedicated local metadata */\ntype Local = {\n  fail: boolean\n  scope: {[key: string]}\n}\n\nlet heap: QueueItem | null = null\n\nconst merge = (a: QueueItem | null, b: QueueItem | null): QueueItem | null => {\n  if (!a) return b\n  if (!b) return a\n\n  let ret\n  if (\n    /**\n     * if both nodes has the same PriorityType\n     * and first node is created after second one\n     */\n    (a.v.type === b.v.type && a.v.id > b.v.id) ||\n    /**\n     * greater priority mean bucket of first node is executed later\n     * e.g  a: \"sampler\", b: \"barrier\"\n     */\n    getPriority(a.v.type) > getPriority(b.v.type)\n  ) {\n    ret = a\n    a = b\n    b = ret\n  }\n  ret = merge(a.r, b)\n  a.r = a.l\n  a.l = ret\n\n  return a\n}\n\n/** queue buckets for each PriorityType */\nconst queue: QueueBucket[] = []\nlet ix = 0\nwhile (ix < 6) {\n  /**\n   * although \"sampler\" and \"barrier\" are using heap instead of linked list,\n   * their buckets are still useful: they maintains size of heap queue\n   */\n  add(queue, {first: null, last: null, size: 0})\n  ix += 1\n}\n\nconst deleteMin = () => {\n  for (let i = 0; i < 6; i++) {\n    const list = queue[i]\n    if (list.size > 0) {\n      /**\n       * bucket 3 is for \"barrier\" PriorityType (used in combine)\n       * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n       */\n      if (i === 3 || i === 4) {\n        list.size -= 1\n        const value = heap!.v\n        heap = merge(heap!.l, heap!.r)\n        return value\n      }\n      if (list.size === 1) {\n        list.last = null\n      }\n      const item = list.first\n      list.first = item!.r\n      list.size -= 1\n      return item!.v\n    }\n  }\n}\nconst pushFirstHeapItem = (\n  type: PriorityTag,\n  page: Leaf | null,\n  node: Node,\n  parent: Stack | null,\n  value,\n  scope?: Scope | null | void,\n) =>\n  pushHeap(\n    0,\n    {\n      a: null,\n      b: null,\n      node,\n      parent,\n      value,\n      page,\n      scope,\n    },\n    type,\n  )\nconst pushHeap = (\n  idx: number,\n  stack: Stack,\n  type: PriorityTag,\n  id: number = 0,\n) => {\n  const priority = getPriority(type)\n  const bucket: QueueBucket = queue[priority]\n  const item: QueueItem = {\n    v: {\n      idx,\n      stack,\n      type,\n      id,\n    },\n    l: null,\n    r: null,\n  }\n  /**\n   * bucket 3 is for \"barrier\" PriorityType (used in combine)\n   * bucket 4 is for \"sampler\" PriorityType (used in sample and guard)\n   */\n  if (priority === 3 || priority === 4) {\n    heap = merge(heap, item)\n  } else {\n    if (bucket.size === 0) {\n      bucket.first = item\n    } else {\n      bucket.last!.r = item\n    }\n    bucket.last = item\n  }\n  bucket.size += 1\n}\n\nconst getPriority = (t: PriorityTag) => {\n  switch (t) {\n    case 'child':\n      return 0\n    case 'pure':\n      return 1\n    case 'read':\n      return 2\n    case BARRIER:\n      return 3\n    case SAMPLER:\n      return 4\n    case EFFECT:\n      return 5\n    default:\n      return -1\n  }\n}\n\nconst barriers = new Set<string | number>()\n\nlet isRoot = true\nexport let isWatch = false\nexport let isPure = false\nexport let currentPage: Leaf | null = null\nexport let forkPage: Scope | void | null\nexport const setForkPage = (newForkPage: Scope) => {\n  forkPage = newForkPage\n}\nexport const setCurrentPage = (newPage: Leaf | null) => {\n  currentPage = newPage\n}\n\nconst getPageForRef = (page: Leaf | null, id: string) => {\n  if (page) {\n    while (page && !page.reg[id]) {\n      page = getParent(page)\n    }\n    if (page) return page\n  }\n  return null\n}\nexport const getPageRef = (\n  page: Leaf | null,\n  forkPage: Scope | null | void,\n  node: Node | null,\n  ref: StateRef,\n  isGetState?: boolean,\n) => {\n  const pageForRef = getPageForRef(page, ref.id)\n  if (pageForRef) return pageForRef.reg[ref.id]\n  if (forkPage) {\n    initRefInScope(forkPage!, ref, isGetState)\n    return forkPage.reg[ref.id]\n  }\n  return ref\n}\n\nexport function launch(config: {\n  target: NodeUnit | NodeUnit[]\n  params?\n  defer?: boolean\n  page?: Leaf | void | null\n  scope?: Scope | void\n  stack?: Stack | void\n}): void\nexport function launch(unit: NodeUnit, payload?, upsert?: boolean): void\nexport function launch(unit, payload?, upsert?: boolean) {\n  let pageForLaunch = currentPage\n  let stackForLaunch = null\n  let forkPageForLaunch = forkPage\n  if (unit.target) {\n    payload = unit.params\n    upsert = unit.defer\n    pageForLaunch = 'page' in unit ? unit.page : pageForLaunch\n    if (unit[STACK]) stackForLaunch = unit[STACK]\n    forkPageForLaunch = getForkPage(unit) || forkPageForLaunch\n    unit = unit.target\n  }\n  if (forkPageForLaunch && forkPage && forkPageForLaunch !== forkPage) {\n    forkPage = null\n  }\n  if (Array.isArray(unit)) {\n    for (let i = 0; i < unit.length; i++) {\n      pushFirstHeapItem(\n        'pure',\n        pageForLaunch,\n        getGraph(unit[i]),\n        stackForLaunch,\n        payload[i],\n        forkPageForLaunch,\n      )\n    }\n  } else {\n    pushFirstHeapItem(\n      'pure',\n      pageForLaunch,\n      getGraph(unit),\n      stackForLaunch,\n      payload,\n      forkPageForLaunch,\n    )\n  }\n  if (upsert && !isRoot) return\n  /** main execution code */\n  const lastStartedState = {\n    isRoot,\n    currentPage,\n    scope: forkPage,\n    isWatch,\n    isPure,\n  }\n  isRoot = false\n  let stop: boolean\n  let skip: boolean\n  let node: Node\n  let value: Layer | undefined\n  let page: Leaf | null\n  let reg: Record<string, StateRef> | void\n  kernelLoop: while ((value = deleteMin())) {\n    const {idx, stack, type} = value\n    node = stack.node\n    currentPage = page = stack.page\n    forkPage = getForkPage(stack)\n    if (page) reg = page.reg\n    else if (forkPage) reg = forkPage.reg\n    // reg = (page ? page : forkPage ? forkPage : node).reg\n    const hasPageReg = !!page\n    const hasScopeReg = !!forkPage\n    const local: Local = {\n      fail: false,\n      scope: node.scope,\n    }\n    stop = skip = false\n    for (let stepn = idx; stepn < node.seq.length && !stop; stepn++) {\n      const step = node.seq[stepn]\n      if (step.order) {\n        const {priority, barrierID} = step.order\n        const id = barrierID\n          ? page\n            ? `${page.fullID}_${barrierID}`\n            : barrierID\n          : 0\n        if (stepn !== idx || type !== priority) {\n          if (barrierID) {\n            if (!barriers.has(id)) {\n              barriers.add(id)\n              pushHeap(stepn, stack, priority, barrierID)\n            }\n          } else {\n            pushHeap(stepn, stack, priority)\n          }\n          continue kernelLoop\n        }\n        barrierID && barriers.delete(id)\n      }\n      switch (step.type) {\n        case 'mov': {\n          const data = step.data\n          let value\n          //prettier-ignore\n          switch (data.from) {\n            case STACK: value = getValue(stack); break\n            case REG_A: /** fall-through case */\n            case 'b':\n              value = stack[data.from]\n              break\n            case VALUE: value = data.store; break\n            case STORE:\n              if (reg && !reg[data.store.id]) {\n                // if (!page.parent) {\n                if (hasPageReg) {\n                  const pageForRef = getPageForRef(page, data.store.id)\n                  stack.page = page = pageForRef\n                  if (pageForRef) {\n                    reg = pageForRef.reg\n                  } else if (hasScopeReg) {\n                    initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                    reg = forkPage!.reg\n                  } else {\n                    reg = undefined //node.reg\n                  }\n                } else if (hasScopeReg) {\n                  /** StateRef in Scope.reg created only when needed */\n                  initRefInScope(forkPage!, data.store, false, true, data.softRead)\n                } else {\n                  // console.error('should not happen')\n                  /** StateRef should exists at least in Node itself, but it is not found */\n                }\n                // }\n              }\n              // value = getPageRef(page, forkPage, node, data.store.id).current\n              value = readRef(reg ? reg[data.store.id] || data.store : data.store)\n              break\n          }\n          //prettier-ignore\n          switch (data.to) {\n            case STACK: stack.value = value; break\n            case REG_A: /** fall-through case */\n            case 'b':\n              stack[data.to] = value\n              break\n            case STORE:\n              getPageRef(page, forkPage, node, data.target).current = value\n              break\n          }\n          break\n        }\n        case 'compute':\n          const data = step.data\n          if (data.fn) {\n            isWatch = getMeta(node, 'op') === 'watch'\n            isPure = data.pure\n            const computationResult = data.safe\n              ? (0 as any, data.fn)(getValue(stack), local.scope, stack)\n              : tryRun(local, data.fn, stack)\n            if (data.filter) {\n              /**\n               * handled edge case: if step.fn will throw,\n               * tryRun will return null\n               * thereby forcing that branch to stop\n               */\n              skip = !computationResult\n            } else {\n              stack.value = computationResult\n            }\n            isWatch = lastStartedState.isWatch\n            isPure = lastStartedState.isPure\n          }\n          break\n      }\n      stop = local.fail || skip\n    }\n    if (!stop) {\n      const finalValue = getValue(stack)\n      forEach(node.next, nextNode => {\n        pushFirstHeapItem(\n          'child',\n          page,\n          nextNode,\n          stack,\n          finalValue,\n          getForkPage(stack),\n        )\n      })\n      const forkPage = getForkPage(stack)\n      if (forkPage) {\n        if (getMeta(node, 'needFxCounter'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.fxCount,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        if (getMeta(node, 'storeChange'))\n          pushFirstHeapItem(\n            'child',\n            page,\n            forkPage.storeChange,\n            stack,\n            finalValue,\n            forkPage,\n          )\n        const additionalLinks = forkPage.additionalLinks[node.id]\n        if (additionalLinks) {\n          forEach(additionalLinks, nextNode => {\n            pushFirstHeapItem(\n              'child',\n              page,\n              nextNode,\n              stack,\n              finalValue,\n              forkPage,\n            )\n          })\n        }\n      }\n    }\n  }\n  isRoot = lastStartedState.isRoot\n  currentPage = lastStartedState.currentPage\n  forkPage = getForkPage(lastStartedState)\n}\n\nexport const initRefInScope = (\n  scope: {\n    reg: Record<string, StateRef>\n    sidValuesMap: Record<string, any>\n    sidIdMap: Record<string, string>\n  },\n  sourceRef: StateRef,\n  isGetState?: boolean,\n  isKernelCall?: boolean,\n  softRead?: boolean,\n) => {\n  const refsMap = scope.reg\n  const sid = sourceRef.sid\n  if (refsMap[sourceRef.id]) return\n  const ref: StateRef = {\n    id: sourceRef.id,\n    current: sourceRef.current,\n  }\n\n  if (sid && sid in scope.sidValuesMap && !(sid in scope.sidIdMap)) {\n    ref.current = scope.sidValuesMap[sid]\n  } else {\n    if (sourceRef.before && !softRead) {\n      let isFresh = false\n      const needToAssign = isGetState || !sourceRef.noInit || isKernelCall\n      forEach(sourceRef.before, cmd => {\n        switch (cmd.type) {\n          case MAP: {\n            const from = cmd.from\n            if (from || cmd.fn) {\n              if (from) initRefInScope(scope, from, isGetState, isKernelCall)\n              const value = from && refsMap[from.id].current\n              if (needToAssign) {\n                ref.current = cmd.fn ? cmd.fn(value) : value\n              }\n            }\n            break\n          }\n          case 'field': {\n            if (!isFresh) {\n              isFresh = true\n              if (Array.isArray(ref.current)) {\n                ref.current = [...ref.current]\n              } else {\n                ref.current = {...ref.current}\n              }\n            }\n            initRefInScope(scope, cmd.from, isGetState, isKernelCall)\n            if (needToAssign) {\n              const from = refsMap[cmd.from.id]\n              ref.current[cmd.field] = refsMap[from.id].current\n            }\n            break\n          }\n          // case 'closure':\n          //   break\n        }\n      })\n    }\n  }\n  if (sid) scope.sidIdMap[sid] = sourceRef.id\n  refsMap[sourceRef.id] = ref\n}\n\n/** try catch for external functions */\nconst tryRun = (local: Local, fn: Function, stack: Stack) => {\n  try {\n    return fn(getValue(stack), local.scope, stack)\n  } catch (err) {\n    console.error(err)\n    local.fail = true\n  }\n}\n","import type {Store, CommonUnit, Domain} from './unit.h'\nimport {is} from './is'\nimport {getParent, getCompositeName} from './getter'\nimport {forIn} from './collection'\n\nexport function unitObjectName(objOrArr, method: string = 'combine') {\n  let name = method + '('\n  let comma = ''\n  let i = 0\n  forIn(objOrArr, unit => {\n    /* inlined max object names constant */\n    if (i < 25) {\n      if (unit != null) {\n        name += comma\n        name += is.unit(unit)\n          ? getCompositeName(unit as CommonUnit | Domain).fullName\n          : unit.toString()\n      }\n      i += 1\n      comma = ', '\n    }\n  })\n  return name + ')'\n}\n\nexport function setStoreName<State>(store: Store<State>, rawName: string) {\n  store.shortName = rawName\n  Object.assign(getCompositeName(store), createName(rawName, getParent(store)))\n}\n\nexport type CompositeName = {\n  shortName: string\n  fullName: string\n  path: string[]\n}\n\nexport function createName(name: string, parent?: Domain): CompositeName {\n  let path: string[]\n  let fullName\n  const shortName = name\n  if (!parent) {\n    path = name.length === 0 ? [] : [name]\n    fullName = name\n  } else {\n    const composite = getCompositeName(parent)\n    if (name.length === 0) {\n      path = composite.path\n      fullName = composite.fullName\n    } else {\n      path = composite.path.concat([name])\n      fullName =\n        composite.fullName.length === 0\n          ? name\n          : '' + composite.fullName + '/' + name\n    }\n  }\n  return {shortName, fullName, path}\n}\n","import {forIn} from './collection'\nimport {assertObject, isObject, isVoid} from './is'\n\nexport function processArgsToConfig(\n  arg,\n  singleArgument: true,\n): [any, any | void]\nexport function processArgsToConfig(args): [any[], any | void]\nexport function processArgsToConfig(\n  args,\n  singleArgument?: boolean,\n): [any[], any | void] {\n  const rawConfig = singleArgument ? args : args[0]\n  assertObject(rawConfig)\n  let metadata = rawConfig.or\n  const childConfig = rawConfig.and\n  if (childConfig) {\n    const unwrappedNestedValue = singleArgument ? childConfig : childConfig[0]\n    /**\n     * if there is no \"and\" field then we reached the leaf of the tree\n     * and this is an original user-defined argument\n     *\n     * note that in this case we're returning all arguments, not the only one been unwrapped\n     **/\n    if (!isObject(unwrappedNestedValue) || !('and' in unwrappedNestedValue)) {\n      args = childConfig\n    } else {\n      //@ts-expect-error\n      const nested = processArgsToConfig(childConfig, singleArgument)\n\n      args = nested[0]\n      metadata = {...metadata, ...nested[1]}\n    }\n  }\n  return [args, metadata]\n}\n\n/**\nprocessed fields:\n\n'name',\n'sid',\n'loc',\n'handler',\n'updateFilter',\n'parent',\n'serialize',\n'named',\n'derived',\n*/\nexport const flattenConfig = (part, config = {}) => {\n  if (isObject(part)) {\n    flattenConfig(part.or, config)\n    forIn(part, (value, field) => {\n      if (!isVoid(value) && field !== 'or' && field !== 'and') {\n        config[field] = value\n      }\n    })\n    flattenConfig(part.and, config)\n  }\n  return config\n}\n","import {readTemplate} from './region'\nimport type {Template, TemplateHandlers} from '../forest/index.h'\n\nexport function applyTemplate<K extends keyof TemplateHandlers>(\n  method: K,\n  ...args: Parameters<TemplateHandlers[K]> extends [Template, ...infer Args]\n    ? Args\n    : never\n): ReturnType<TemplateHandlers[K]> | void {\n  const template = readTemplate()\n  if (template) {\n    const fn = template.handlers[method]\n    if (fn) return fn(template, ...args)\n  }\n}\n","import {observableSymbol} from './observable'\n\nimport {\n  is,\n  isObject,\n  isFunction,\n  assertObject,\n  assertNodeSet,\n  isVoid,\n} from './is'\nimport type {Store, Event, CommonUnit, Effect} from './unit.h'\n\nimport {calc, mov, read, userFnCall} from './step'\nimport {createStateRef, readRef, addRefOp} from './stateRef'\nimport {nextUnitID} from './id'\nimport {callStackAReg, callARegStack, callStack} from './caller'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {\n  launch,\n  currentPage,\n  forkPage,\n  setCurrentPage,\n  initRefInScope,\n  isPure,\n} from './kernel'\n\nimport type {Subscriber, Config} from './index.h'\nimport {createName} from './naming'\nimport {createLinkNode} from './forward'\nimport {watchUnit} from './watch'\nimport {createSubscription} from './subscription'\nimport {readTemplate, readSidRoot} from './region'\nimport {\n  getSubscribers,\n  getStoreState,\n  getGraph,\n  getParent,\n  setMeta,\n  getMeta,\n} from './getter'\nimport {assert, deprecate} from './throw'\nimport {DOMAIN, STORE, EVENT, MAP, FILTER, STACK, REG_A} from './tag'\nimport {applyTemplate} from './template'\nimport {forEach} from './collection'\nimport {flattenConfig} from './config'\nimport type {Template} from '../forest/index.h'\n\nexport const applyParentHook = (\n  source,\n  target,\n  hookType: 'event' | 'effect' = EVENT,\n) => {\n  if (getParent(source)) getParent(source).hooks[hookType](target)\n}\n\nexport const initUnit = (kind, unit, configA, configB?) => {\n  const isDomain = kind === DOMAIN\n  const id = nextUnitID()\n  const config = flattenConfig({\n    or: configB,\n    and: typeof configA === 'string' ? {name: configA} : configA,\n  })\n  const {parent = null, sid = null, named = null} = config\n  const name = named ? named : config.name || (isDomain ? '' : id)\n  const compositeName = createName(name, parent)\n  const meta: Record<string, any> = {\n    op: (unit.kind = kind),\n    name: (unit.shortName = name),\n    sid: (unit.sid = readSidRoot(sid)),\n    named,\n    unitId: (unit.id = id),\n    serialize: config.serialize,\n    derived: config.derived,\n    config,\n  }\n  unit.parent = parent\n  unit.compositeName = compositeName\n  unit.defaultConfig = config\n  unit.thru = (fn: Function) => {\n    deprecate(false, 'thru', 'js pipe')\n    return fn(unit)\n  }\n  unit.getType = () => compositeName.fullName\n  if (!isDomain) {\n    unit.subscribe = (observer: Subscriber<any>) => {\n      assertObject(observer)\n      return unit.watch(\n        isFunction(observer)\n          ? observer\n          : upd => observer.next && observer.next(upd),\n      )\n    }\n    unit[observableSymbol] = () => unit\n    const template = readTemplate()\n    if (template) meta.nativeTemplate = template\n  }\n  return meta\n}\nexport const createNamedEvent = (named: string) => createEvent({named})\n\nconst deriveEvent = (event, op: string, fn, node) => {\n  let config\n  if (isObject(fn)) {\n    config = fn\n    fn = fn.fn\n  }\n  const mapped = createEvent({\n    name: `${event.shortName} → *`,\n    derived: true,\n    and: config,\n  })\n  createLinkNode(event, mapped, node, op, fn)\n  return mapped\n}\n\nfunction callCreate<T>(\n  unit: Event<T> | Effect<T, any, any>,\n  template: Template | null,\n  payload: T,\n  args: any[],\n) {\n  const oldPage = currentPage\n  let page = null\n  if (template) {\n    page = currentPage\n    while (page && page.template !== template) {\n      page = getParent(page)\n    }\n  }\n  setCurrentPage(page)\n  const result = unit.create(payload, args)\n  setCurrentPage(oldPage)\n  return result\n}\n\nexport function createEvent<Payload = any>(\n  nameOrConfig?,\n  maybeConfig?,\n): Event<Payload> {\n  const event = ((payload: Payload, ...args: unknown[]) => {\n    deprecate(\n      !getMeta(event, 'derived'),\n      'call of derived event',\n      'createEvent',\n    )\n    deprecate(!isPure, 'unit call from pure function', 'operators like sample')\n    if (currentPage) {\n      return callCreate(event, template, payload, args)\n    }\n    return event.create(payload, args)\n  }) as Event<Payload>\n  const template = readTemplate()\n  return Object.assign(event, {\n    graphite: createNode({\n      meta: initUnit(EVENT, event, nameOrConfig, maybeConfig),\n      regional: true,\n    }),\n    create(params: Payload, _: any[]) {\n      launch({target: event, params, scope: forkPage!})\n      return params\n    },\n    watch: (fn: (payload: Payload) => any) => watchUnit(event, fn),\n    map: (fn: Function) => deriveEvent(event, MAP, fn, [userFnCall()]),\n    filter: (fn: {fn: Function}) =>\n      deriveEvent(event, FILTER, fn.fn ? fn : fn.fn, [\n        userFnCall(callStack, true),\n      ]),\n    filterMap: (fn: Function) =>\n      deriveEvent(event, 'filterMap', fn, [\n        userFnCall(),\n        calc(value => !isVoid(value), true),\n      ]),\n    prepend(fn: Function) {\n      const contramapped: Event<any> = createEvent('* → ' + event.shortName, {\n        parent: getParent(event),\n      })\n      applyTemplate('eventPrepend', getGraph(contramapped))\n      createLinkNode(contramapped, event, [userFnCall()], 'prepend', fn)\n      applyParentHook(event, contramapped)\n      return contramapped\n    },\n  })\n}\n\nexport function createStore<State>(\n  defaultState: State,\n  props?: Config,\n): Store<State> {\n  const plainState = createStateRef(defaultState)\n  const updates = createNamedEvent('updates')\n  applyTemplate('storeBase', plainState)\n  const plainStateId = plainState.id\n  const store = {\n    subscribers: new Map(),\n    updates,\n    defaultState,\n    stateRef: plainState,\n    getState() {\n      let targetRef = plainState\n      let reachedPage\n      if (currentPage) {\n        let page = currentPage\n        while (page && !page.reg[plainStateId]) {\n          page = getParent(page)\n        }\n        if (page) reachedPage = page\n      }\n      if (!reachedPage && forkPage) {\n        initRefInScope(forkPage, plainState, true)\n        reachedPage = forkPage\n      }\n      if (reachedPage) targetRef = reachedPage.reg[plainStateId]\n      return readRef(targetRef)\n    },\n    setState: (state: State) =>\n      launch({\n        target: store,\n        params: state,\n        defer: true,\n        scope: forkPage!,\n      }),\n    reset(...units: CommonUnit[]) {\n      forEach(units, unit => store.on(unit, () => store.defaultState))\n      return store\n    },\n    on(nodeSet: CommonUnit | CommonUnit[], fn: Function) {\n      assertNodeSet(nodeSet, '.on', 'first argument')\n      deprecate(\n        !getMeta(store, 'derived'),\n        '.on in derived store',\n        'createStore',\n      )\n      forEach(Array.isArray(nodeSet) ? nodeSet : [nodeSet], trigger => {\n        store.off(trigger)\n        getSubscribers(store).set(\n          trigger,\n          createSubscription(\n            updateStore(trigger, store, 'on', callARegStack, fn),\n          ),\n        )\n      })\n      return store\n    },\n    off(unit: CommonUnit) {\n      const currentSubscription = getSubscribers(store).get(unit)\n      if (currentSubscription) {\n        currentSubscription()\n        getSubscribers(store).delete(unit)\n      }\n      return store\n    },\n    map(fn: (value: any, prevArg?: any) => any, firstState?: any) {\n      let config\n      if (isObject(fn)) {\n        config = fn\n        fn = (fn as unknown as {fn: (value: any) => any}).fn\n      }\n      deprecate(\n        isVoid(firstState),\n        'second argument of store.map',\n        'updateFilter',\n      )\n      let lastResult\n      const storeState = store.getState()\n      const template = readTemplate()\n      if (template) {\n        lastResult = null\n      } else if (!isVoid(storeState)) {\n        lastResult = fn(storeState, firstState)\n      }\n\n      const innerStore: Store<any> = createStore(lastResult, {\n        name: `${store.shortName} → *`,\n        derived: true,\n        and: config,\n      })\n      const linkNode = updateStore(store, innerStore, MAP, callStackAReg, fn)\n      addRefOp(getStoreState(innerStore), {\n        type: MAP,\n        fn,\n        from: plainState,\n      })\n      getStoreState(innerStore).noInit = true\n      applyTemplate('storeMap', plainState, linkNode)\n      return innerStore\n    },\n    watch(eventOrFn, fn?: Function) {\n      if (!fn || !is.unit(eventOrFn)) {\n        const subscription = watchUnit(store, eventOrFn)\n        if (!applyTemplate('storeWatch', plainState, eventOrFn)) {\n          eventOrFn(store.getState())\n        }\n        return subscription\n      }\n      assert(isFunction(fn), 'second argument should be a function')\n      return eventOrFn.watch(payload => fn(store.getState(), payload))\n    },\n  } as unknown as Store<State>\n  const meta = initUnit(STORE, store, props)\n  const updateFilter = store.defaultConfig.updateFilter\n  store.graphite = createNode({\n    scope: {state: plainState, fn: updateFilter},\n    node: [\n      calc((upd, _, stack) => {\n        if (stack.scope && !stack.scope.reg[plainState.id]) {\n          stack.b = true\n        }\n        return upd\n      }),\n      read(plainState),\n      calc((upd, _, {a, b}) => !isVoid(upd) && (upd !== a || b), true),\n      updateFilter && userFnCall(callStackAReg, true),\n      mov({from: STACK, target: plainState}),\n    ],\n    child: updates,\n    meta,\n    regional: true,\n  })\n  const sid: string | null = getMeta(store, 'sid')\n  if (sid) {\n    if (getMeta(store, 'serialize') !== 'ignore')\n      setMeta(store, 'storeChange', true)\n    plainState.sid = sid\n  }\n  assert(\n    getMeta(store, 'derived') || !isVoid(defaultState),\n    \"current state can't be undefined, use null instead\",\n  )\n  own(store, [updates])\n  return store\n}\n\nconst updateStore = (\n  from: CommonUnit,\n  store: Store<any>,\n  op: string,\n  caller: typeof callStackAReg,\n  fn: Function,\n) => {\n  const storeRef = getStoreState(store)\n  const reader = mov({\n    store: storeRef,\n    to: REG_A,\n    priority: 'read',\n  })\n  if (op === MAP) reader.data.softRead = true\n  const node = [reader, userFnCall(caller)]\n  applyTemplate(\n    'storeOnMap',\n    storeRef,\n    node,\n    is.store(from) && getStoreState(from),\n  )\n  return createLinkNode(from, store, node, op, fn)\n}\n","export const STORE = 'store'\nexport const EVENT = 'event'\nexport const EFFECT = 'effect'\nexport const DOMAIN = 'domain'\nexport const SCOPE = 'scope'\nexport const SAMPLER = 'sampler'\nexport const CROSSLINK = 'crosslink'\nexport const MAP = 'map'\nexport const STACK = 'stack'\nexport const BARRIER = 'barrier'\nexport const VALUE = 'value'\nexport const SAMPLE = 'sample'\nexport const FILTER = 'filter'\nexport const REG_A = 'a'\n","import type {Store} from './unit.h'\nimport {createStore} from './createUnit'\nimport {createStateRef, addRefOp} from './stateRef'\nimport {mov, calc, read, userFnCall} from './step'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, setMeta} from './getter'\nimport {is, isFunction, isObject, isVoid} from './is'\nimport {unitObjectName} from './naming'\nimport {createLinkNode} from './forward'\nimport {assert, deprecate} from './throw'\nimport {readTemplate} from './region'\nimport {forIn} from './collection'\nimport {BARRIER, MAP, REG_A, VALUE} from './tag'\nimport {applyTemplate} from './template'\nimport type {Config} from './index.h'\n\nexport function combine(...args): Store<any> {\n  let handler\n  let stores\n  let config\n  ;[args, config] = processArgsToConfig(args)\n  const rawHandler = args[args.length - 1]\n  if (isFunction(rawHandler)) {\n    stores = args.slice(0, -1)\n    handler = rawHandler\n  } else {\n    stores = args\n  }\n\n  let structStoreShape\n  let shapeReady\n  if (stores.length === 1) {\n    const obj = stores[0]\n    /*\n      without edge case combine(Color, (Color) => '~')\n      */\n    if (!is.store(obj)) {\n      /*\n      case combine([R,G,B], ([R,G,B]) => '~')\n      case combine({R,G,B}, ({R,G,B}) => '~')\n\n      edge case combine([Color], ([Color]) => '~')\n      edge case combine({Color}, ({Color}) => '~')\n\n      edge case combine([R,G,B])\n      edge case combine({R,G,B})\n\n      edge case combine([Color])\n      edge case combine({Color})\n      */\n      structStoreShape = obj\n      shapeReady = true\n    }\n  }\n  let noArraySpread: boolean | void\n  if (!shapeReady) {\n    /*\n    case combine(R,G,B, (R,G,B) => '~')\n    */\n    structStoreShape = stores\n    /*\n    without edge case combine(R,G,B)\n    without edge case combine(Color)\n    */\n    if (handler) {\n      noArraySpread = true\n      const fn = handler\n      handler = list => fn(...list)\n    }\n  }\n  assert(isObject(structStoreShape), 'shape should be an object')\n  return storeCombination(\n    Array.isArray(structStoreShape),\n    !noArraySpread,\n    structStoreShape,\n    config,\n    handler,\n  )\n}\n\nconst storeCombination = (\n  isArray: boolean,\n  needSpread: boolean,\n  obj,\n  config?: Config,\n  fn?: (upd) => any,\n) => {\n  const clone = isArray ? list => list.slice() : obj => ({...obj})\n  const defaultState = isArray ? [] : {}\n\n  const stateNew = clone(defaultState)\n  const rawShape = createStateRef(stateNew)\n  const isFresh = createStateRef(true)\n  rawShape.type = isArray ? 'list' : 'shape'\n  rawShape.noInit = true\n  applyTemplate('combineBase', rawShape, isFresh)\n  const store = createStore(stateNew, {\n    name: unitObjectName(obj),\n    derived: true,\n    and: config,\n  })\n  const storeStateRef = getStoreState(store)\n  storeStateRef.noInit = true\n  setMeta(store, 'isCombine', true)\n  const rawShapeReader = read(rawShape)\n  /**\n   * usual ref reading has very high priority, which leads to data races\n   * ref reading for combine should have same \"barrier\" priority but without batching\n   * (thats why order has no \"barrierID\" field, which assume batching)\n   **/\n  rawShapeReader.order = {priority: 'barrier'}\n  const node = [\n    calc((upd, _, stack) => {\n      if (stack.scope && !stack.scope.reg[rawShape.id]) {\n        stack.c = true\n      }\n      return upd\n    }),\n    rawShapeReader,\n    mov({store: isFresh, to: 'b'}),\n    calc((upd, {key}, reg) => {\n      if (reg.c || upd !== reg.a[key]) {\n        if (needSpread && reg.b) {\n          reg.a = clone(reg.a)\n        }\n        reg.a[key] = upd\n        return true\n      }\n    }, true),\n    mov({from: REG_A, target: rawShape}),\n    mov({from: VALUE, store: false, target: isFresh}),\n    mov({\n      from: VALUE,\n      store: true,\n      target: isFresh,\n      priority: BARRIER,\n      batch: true,\n    }),\n    read(rawShape, true),\n    fn && userFnCall(),\n  ]\n  forIn(obj, (child: Store<any> | any, key) => {\n    if (!is.store(child)) {\n      assert(\n        !is.unit(child) && !isVoid(child),\n        `combine expects a store in a field ${key}`,\n      )\n      stateNew[key] = defaultState[key] = child\n      return\n    }\n    defaultState[key] = child.defaultState\n    stateNew[key] = child.getState()\n    const linkNode = createLinkNode(child, store, node, 'combine', fn)\n    linkNode.scope.key = key\n    const childRef = getStoreState(child)\n    addRefOp(rawShape, {type: 'field', field: key, from: childRef})\n    applyTemplate('combineField', childRef, linkNode)\n  })\n\n  store.defaultShape = obj\n  addRefOp(storeStateRef, {\n    type: MAP,\n    from: rawShape,\n    fn,\n  })\n  if (!readTemplate()) {\n    store.defaultState = fn\n      ? (storeStateRef.current = fn(stateNew))\n      : defaultState\n  }\n  return store\n}\n\nexport function createStoreObject(...args) {\n  deprecate(false, 'createStoreObject', 'combine')\n  return combine(...args)\n}\n","export function createDefer(): {\n  rs: (value) => any\n  rj: (value) => any\n  req: Promise<any>\n} {\n  const result = {} as {\n    rs: (value) => any\n    rj: (value) => any\n    req: Promise<any>\n  }\n  result.req = new Promise((rs, rj) => {\n    result.rs = rs\n    result.rj = rj\n  })\n  result.req.catch(err => {})\n  return result\n}\n","import type {Unit} from './index.h'\nimport type {Effect} from './unit.h'\nimport {calc, run} from './step'\nimport {getForkPage, getGraph, getMeta, getParent, setMeta} from './getter'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport {launch, setForkPage, forkPage, isWatch, Stack} from './kernel'\nimport {createNamedEvent, createStore, createEvent} from './createUnit'\nimport {createDefer} from './defer'\nimport {isObject, isFunction} from './is'\nimport {assert} from './throw'\nimport {EFFECT} from './tag'\nimport {add} from './collection'\n\nexport function createEffect<Payload, Done, Fail = Error>(\n  nameOrConfig,\n  maybeConfig?,\n): Effect<Payload, Done, Fail> {\n  const instance = createEvent(\n    isFunction(nameOrConfig) ? {handler: nameOrConfig} : nameOrConfig,\n    maybeConfig,\n  ) as unknown as Effect<Payload, Done, Fail>\n  const node = getGraph(instance)\n  setMeta(node, 'op', (instance.kind = EFFECT))\n  //@ts-expect-error\n  instance.use = (fn: Function) => {\n    assert(isFunction(fn), '.use argument should be a function')\n    runner.scope.handler = fn\n    return instance\n  }\n  instance.use.getCurrent = () => runner.scope.handler\n  const anyway = (instance.finally = createNamedEvent('finally'))\n  const done = (instance.done = (anyway as any).filterMap({\n    named: 'done',\n    fn({status, params, result}) {\n      if (status === 'done') return {params, result}\n    },\n  }))\n  const fail = (instance.fail = (anyway as any).filterMap({\n    named: 'fail',\n    fn({status, params, error}) {\n      if (status === 'fail') return {params, error}\n    },\n  }))\n  const doneData = (instance.doneData = done.map({\n    named: 'doneData',\n    fn: ({result}) => result,\n  }))\n  const failData = (instance.failData = fail.map({\n    named: 'failData',\n    fn: ({error}) => error,\n  }))\n\n  const runner = createNode({\n    scope: {\n      handlerId: getMeta(node, 'sid'),\n      handler:\n        instance.defaultConfig.handler ||\n        (() => assert(false, `no handler used in ${instance.getType()}`)),\n    },\n    node: [\n      calc(\n        (upd, scope_, stack) => {\n          const scope: {handlerId: string; handler: Function} = scope_ as any\n          let handler = scope.handler\n          if (getForkPage(stack)) {\n            const handler_ = getForkPage(stack)!.handlers[scope.handlerId]\n            if (handler_) handler = handler_\n          }\n          upd.handler = handler\n          return upd\n        },\n        false,\n        true,\n      ),\n      calc(\n        ({params, req, handler, args = [params]}, _, stack) => {\n          const onResolve = onSettled(params, req, true, anyway, stack)\n          const onReject = onSettled(params, req, false, anyway, stack)\n          const [ok, result] = runFn(handler, onReject, args)\n          if (ok) {\n            if (isObject(result) && isFunction(result.then)) {\n              result.then(onResolve, onReject)\n            } else {\n              onResolve(result)\n            }\n          }\n        },\n        false,\n        true,\n      ),\n    ],\n    meta: {op: 'fx', fx: 'runner'},\n  })\n  node.scope.runner = runner\n  add(\n    node.seq,\n    calc(\n      (params, {runner}, stack) => {\n        const upd = getParent(stack)\n          ? {params, req: {rs(data) {}, rj(data) {}}}\n          : /** empty stack means that this node was launched directly */\n            params\n        launch({\n          target: runner,\n          params: upd,\n          defer: true,\n          scope: getForkPage(stack),\n        })\n        return upd.params\n      },\n      false,\n      true,\n    ),\n  )\n  //@ts-expect-error\n  instance.create = (params: Payload) => {\n    const req = createDefer()\n    const payload = {params, req}\n    if (forkPage) {\n      if (!isWatch) {\n        const savedFork = forkPage\n        req.req\n          .finally(() => {\n            setForkPage(savedFork)\n          })\n          .catch(() => {})\n      }\n      launch({target: instance, params: payload, scope: forkPage})\n    } else {\n      launch(instance, payload)\n    }\n    return req.req\n  }\n\n  const inFlight = (instance.inFlight = createStore(0, {named: 'inFlight'})\n    .on(instance, x => x + 1)\n    .on(anyway, x => x - 1))\n  setMeta(anyway, 'needFxCounter', 'dec')\n  setMeta(instance, 'needFxCounter', true)\n  const pending = (instance.pending = inFlight.map({\n    //@ts-expect-error\n    fn: amount => amount > 0,\n    named: 'pending',\n  }))\n\n  own(instance, [anyway, done, fail, doneData, failData, pending, inFlight])\n  return instance\n}\nexport const runFn = (\n  fn: Function,\n  onReject: (data) => void,\n  args,\n): [boolean, any] => {\n  try {\n    return [true, fn(...args)]\n  } catch (err) {\n    onReject(err)\n    return [false, null]\n  }\n}\n\nexport const onSettled =\n  (\n    params,\n    req: {\n      rs(_)\n      rj(_)\n    },\n    ok: boolean,\n    anyway: Unit,\n    stack: Stack,\n  ) =>\n  data =>\n    launch({\n      target: [anyway, sidechain],\n      params: [\n        ok\n          ? {status: 'done', params, result: data}\n          : {status: 'fail', params, error: data},\n        {value: data, fn: ok ? req.rs : req.rj},\n      ],\n      defer: true,\n      page: stack.page,\n      scope: getForkPage(stack),\n    })\n\nconst sidechain = createNode({\n  node: [run({fn: ({fn, value}) => fn(value)})],\n  meta: {op: 'fx', fx: 'sidechain'},\n})\n","import type {Store, Event, Effect} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {createLinkNode} from './forward'\nimport {unitObjectName} from './naming'\nimport {assertNodeSet} from './is'\n\nexport function merge<T>(\n  units: Array<Event<T> | Store<T> | Effect<T, any, any>>,\n  config?: object,\n): Event<T> {\n  assertNodeSet(units, 'merge', 'first argument')\n  const result = createEvent({\n    name: unitObjectName(units, 'merge'),\n    derived: true,\n    and: config,\n  })\n  createLinkNode(units, result, [], 'merge')\n  return result\n}\n","import type {Cmd, StateRef} from './index.h'\nimport type {CommonUnit, DataCarrier} from './unit.h'\nimport {combine} from './combine'\nimport {mov, userFnCall, read, calc} from './step'\nimport {createStateRef, readRef} from './stateRef'\nimport {callStackAReg} from './caller'\nimport {processArgsToConfig} from './config'\nimport {getStoreState, getGraph} from './getter'\nimport {\n  assertNodeSet,\n  assertTarget,\n  is,\n  isObject,\n  isVoid,\n  isFunction,\n} from './is'\nimport {createStore} from './createUnit'\nimport {createEvent} from './createUnit'\nimport {createNode} from './createNode'\nimport {assert} from './throw'\nimport {forEach} from './collection'\nimport {SAMPLE, STACK, VALUE} from './tag'\nimport {merge} from './merge'\nimport {applyTemplate} from './template'\nimport {own} from './own'\nimport {createLinkNode} from './forward'\n\nconst sampleConfigFields = ['source', 'clock', 'target']\n\nconst fieldErrorMessage = (method: string, field: string) =>\n  method + `: ${field} should be defined`\n\nexport function validateSampleConfig(config, method: string) {\n  let atLeastOneFieldExists = false\n  forEach(sampleConfigFields, field => {\n    if (field in config) {\n      assert(config[field] != null, fieldErrorMessage(method, field))\n      atLeastOneFieldExists = true\n    }\n  })\n  return atLeastOneFieldExists\n}\n\nexport function sample(...args) {\n  let target\n  let name\n  let [[source, clock, fn], metadata] = processArgsToConfig(args)\n  let sid\n  let batched = true\n  let filter\n  /** config case */\n  if (\n    isVoid(clock) &&\n    isObject(source) &&\n    validateSampleConfig(source, SAMPLE)\n  ) {\n    clock = source.clock\n    fn = source.fn\n    batched = !source.greedy\n    filter = source.filter\n    /** optional target & name accepted only from config */\n    target = source.target\n    name = source.name\n    sid = source.sid\n    source = source.source\n  }\n  return createSampling(\n    SAMPLE,\n    clock,\n    source,\n    filter,\n    target,\n    fn,\n    name,\n    metadata,\n    batched,\n    true,\n    false,\n    sid,\n  )\n}\n\nexport const createSampling = (\n  method: string,\n  clock: DataCarrier | DataCarrier[] | void,\n  source: DataCarrier | Array<Store<any>> | Record<string, Store<any>> | void,\n  filter: any,\n  target: DataCarrier | DataCarrier[] | void,\n  fn: any,\n  name: string | undefined,\n  metadata: object | void,\n  batched: boolean,\n  targetMayBeStore: boolean,\n  filterRequired: boolean,\n  sid?: string | undefined,\n) => {\n  const isUpward = !!target\n  assert(\n    !isVoid(source) || !isVoid(clock),\n    fieldErrorMessage(method, 'either source or clock'),\n  )\n  let sourceIsClock = false\n  if (isVoid(source)) {\n    sourceIsClock = true\n  } else if (!is.unit(source)) {\n    source = combine(source)\n  }\n  if (isVoid(clock)) {\n    /** still undefined! */\n    clock = source\n  } else {\n    assertNodeSet(clock, method, 'clock')\n    if (Array.isArray(clock)) {\n      clock = merge(clock as CommonUnit[])\n    }\n  }\n  if (sourceIsClock) {\n    source = clock\n  }\n  if (!metadata && !name) name = source.shortName\n  let filterType: 'none' | 'unit' | 'fn' = 'none'\n  if (filterRequired || filter) {\n    if (is.unit(filter)) {\n      filterType = 'unit'\n    } else {\n      assert(isFunction(filter), '`filter` should be function or unit')\n      filterType = 'fn'\n    }\n  }\n  if (target) {\n    assertNodeSet(target, method, 'target')\n    assertTarget(method, target)\n  } else {\n    if (\n      filterType === 'none' &&\n      targetMayBeStore &&\n      is.store(source) &&\n      is.store(clock)\n    ) {\n      const initialState = fn\n        ? fn(readRef(getStoreState(source)), readRef(getStoreState(clock)))\n        : readRef(getStoreState(source))\n      target = createStore(initialState, {name, sid, or: metadata})\n    } else {\n      target = createEvent({name, derived: true, or: metadata})\n      applyTemplate('sampleTarget', getGraph(target))\n    }\n  }\n  // const targetTemplate =\n  //   isUpward && is.unit(target) && getGraph(target).meta.nativeTemplate\n  const clockState = createStateRef()\n  let filterNodes: Cmd[] = []\n  if (filterType === 'unit') {\n    const [filterRef, hasFilter] = syncSourceState(\n      filter as DataCarrier,\n      target,\n      clock,\n      clockState,\n      method,\n    )\n    filterNodes = [...readAndFilter(hasFilter), ...readAndFilter(filterRef)]\n  }\n  const [sourceRef, hasSource] = syncSourceState(\n    source,\n    target,\n    clock,\n    clockState,\n    method,\n  )\n  own(source, [\n    createLinkNode(\n      clock,\n      target,\n      [\n        applyTemplate('sampleSourceLoader'),\n        mov({from: STACK, target: clockState}),\n        ...readAndFilter(hasSource),\n        read(sourceRef, true, batched),\n        ...filterNodes,\n        read(clockState),\n        filterType === 'fn' &&\n          userFnCall((src, _, {a}) => filter(src, a), true),\n        fn && userFnCall(callStackAReg),\n        applyTemplate('sampleSourceUpward', isUpward),\n      ],\n      method,\n      fn,\n    ),\n  ])\n  return target\n}\n\nconst readAndFilter = (state: StateRef) => [\n  read(state),\n  calc((upd, scope, {a}) => a, true),\n]\n\nconst syncSourceState = (\n  source: DataCarrier,\n  target: DataCarrier | DataCarrier[],\n  clock: DataCarrier | DataCarrier[],\n  clockState: StateRef,\n  method: string,\n) => {\n  const isSourceStore = is.store(source)\n  const sourceRef = isSourceStore ? getStoreState(source) : createStateRef()\n  const hasSource = createStateRef(isSourceStore)\n  if (!isSourceStore) {\n    createNode({\n      parent: source,\n      node: [\n        mov({from: STACK, target: sourceRef}),\n        mov({from: VALUE, store: true, target: hasSource}),\n      ],\n      family: {owners: [source, target, clock], links: target},\n      meta: {op: method},\n      regional: true,\n    })\n  }\n  applyTemplate('sampleSource', hasSource, sourceRef, clockState)\n  return [sourceRef, hasSource] as const\n}\n","import {getMeta, getOwners, getLinks} from '../getter'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport type {Store} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, forEach, includes} from '../collection'\nimport {STORE} from '../tag'\n\nexport function traverseStores(\n  root: Node,\n  fn: (node: Node, sid: string) => void,\n) {\n  const list = [] as Node[]\n  ;(function visit(node) {\n    if (includes(list, node)) return\n    add(list, node)\n    if (getMeta(node, 'op') === STORE && getMeta(node, 'sid')) {\n      fn(node, getMeta(node, 'sid'))\n    }\n    forEach(node.next, visit)\n    forEach(getOwners(node), visit)\n    forEach(getLinks(node), visit)\n  })(root)\n}\n\nexport function normalizeValues(\n  values: Map<Store<any>, any> | Array<[any, any]> | Record<string, any>,\n  assertEach?: (key, value) => void,\n) {\n  if (Array.isArray(values)) values = new Map(values)\n  if (values instanceof Map) {\n    const result = {} as Record<string, any>\n    forEach(values, (value, key) => {\n      assert(is.unit(key), 'Map key should be a unit')\n      if (assertEach) assertEach(key, value)\n      assert(key.sid, 'unit should have a sid')\n      assert(!(key.sid! in result), 'duplicate sid found')\n      result[key.sid!] = value\n    })\n    return result\n  }\n  return values\n}\n","export const observableSymbol =\n  (typeof Symbol !== 'undefined' && Symbol.observable) || '@@observable'\n","import {kind} from './index.h'\nimport {DOMAIN, STORE, EVENT, EFFECT, SCOPE} from './tag'\nimport {isObject, isFunction} from './is'\nimport {Domain, Effect, Event, Scope, Store} from './unit.h'\n\nexport const unit = obj => (isFunction(obj) || isObject(obj)) && 'kind' in obj\n\nconst is = (type: kind) => obj => unit(obj) && obj.kind === type\n\nexport const store = is(STORE) as (value) => value is Store<unknown>\nexport const event = is(EVENT) as (value) => value is Event<unknown>\nexport const effect = is(EFFECT) as (\n  value,\n) => value is Effect<unknown, unknown, unknown>\nexport const domain = is(DOMAIN) as (value) => value is Domain\nexport const scope = is(SCOPE) as (value) => value is Scope\n","import type {Node, StateRef, NodeUnit} from './index.h'\nimport type {Scope, Store, CommonUnit, Domain} from './unit.h'\n\nexport const getGraph = (graph: NodeUnit): Node =>\n  (graph as {graphite: Node}).graphite || graph\nexport const getOwners = (node: Node) => node.family.owners\nexport const getLinks = (node: Node) => node.family.links\nexport const getStoreState = (store: Store<any>): StateRef => store.stateRef\nexport const getValue = stack => stack.value\nexport const getSubscribers = (store: Store<any>) => store.subscribers\nexport const getParent = unit => unit.parent\nexport const getForkPage = (val): Scope | void => val.scope\nexport const getMeta = (unit: NodeUnit, field: string) =>\n  getGraph(unit).meta[field]\nexport const setMeta = (unit: NodeUnit, field: string, value: unknown) =>\n  (getGraph(unit).meta[field] = value)\nexport const getCompositeName = (unit: CommonUnit | Domain) =>\n  unit.compositeName\n","const idCount = () => {\n  let id = 0\n  return () => `${++id}`\n}\n\nexport const nextUnitID = idCount()\nexport const nextStepID = idCount()\nexport const nextNodeID = idCount()\n","import type {NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks} from './getter'\nimport {DOMAIN, CROSSLINK} from './tag'\nimport {add, forEach} from './collection'\n\nexport const own = (ownerUnit: NodeUnit, links: NodeUnit[]) => {\n  const owner = getGraph(ownerUnit)\n  forEach(links, _link => {\n    const link = getGraph(_link)\n    if (owner.family.type !== DOMAIN) link.family.type = CROSSLINK\n    add(getOwners(link), owner)\n    add(getLinks(owner), link)\n  })\n}\n","export * as is from './validate'\nimport {forEach} from './collection'\nimport {assert, deprecate} from './throw'\nimport {arrifyNodes} from './createNode'\nimport type {NodeUnit} from './index.h'\nimport {getMeta} from './getter'\n\nexport const isObject = value => typeof value === 'object' && value !== null\nexport const isFunction = value => typeof value === 'function'\n\nexport const isVoid = value => value === undefined\n\nexport const assertObject = value =>\n  assert(\n    isObject(value) || isFunction(value),\n    'expect first argument be an object',\n  ) // or function\n\nconst assertNodeSetItem = (\n  value,\n  method: string,\n  valueName: string,\n  reason: string,\n) =>\n  assert(\n    !(\n      (!isObject(value) && !isFunction(value)) ||\n      (!('family' in value) && !('graphite' in value))\n    ),\n    `${method}: expect ${valueName} to be a unit (store, event or effect)${reason}`,\n  )\n\nexport const assertNodeSet = (value, method: string, valueName: string) => {\n  if (Array.isArray(value)) {\n    forEach(value, (item, i) =>\n      assertNodeSetItem(item, method, `${i} item of ${valueName}`, ''),\n    )\n  } else {\n    assertNodeSetItem(value, method, valueName, ' or array of units')\n  }\n}\n\nexport const assertTarget = (\n  method: string,\n  target: NodeUnit | NodeUnit[],\n  targetField: string = 'target',\n) =>\n  forEach(arrifyNodes(target), item =>\n    deprecate(\n      !getMeta(item, 'derived'),\n      `${method}: derived unit in \"${targetField}\"`,\n      `createEvent/createStore`,\n    ),\n  )\n","import type {Stack} from './kernel'\n\nexport const callStackAReg = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(stack, a)\nexport const callARegStack = (\n  stack: any,\n  {fn}: {[key: string]: any},\n  {a}: Stack,\n) => fn(a, stack)\nexport const callStack = (stack: any, {fn}: {[key: string]: any}, _: Stack) =>\n  fn(stack)\n","import type {\n  StateRef,\n  Compute,\n  MovValueToRegister,\n  MovValueToStore,\n  MovStoreToRegister,\n  MovStoreToStore,\n  MovRegisterToStore,\n} from './index.h'\nimport {nextStepID} from './id'\nimport {EFFECT, REG_A, SAMPLER, STACK, STORE} from './tag'\nimport type {BarrierPriorityTag, Stack} from './kernel'\nimport {callStack} from './caller'\n\nconst cmd = (\n  type: 'compute' | 'mov',\n  data,\n  priority?: BarrierPriorityTag | false,\n  batch?: boolean,\n) => {\n  const result = {\n    id: nextStepID(),\n    type,\n    data,\n  }\n  if (priority) {\n    result.order = {priority}\n    if (batch) result.order.barrierID = ++nextBarrierID\n  }\n  return result\n}\n\nlet nextBarrierID = 0\n\nexport const mov: {\n  <T>(data: {\n    from: 'value'\n    store: T\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToStore<T>\n  <T>(data: {\n    from: 'value'\n    to: 'stack' | 'a' | 'b'\n    store: T\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovValueToRegister<T>\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    from: 'a' | 'b' | 'stack'\n    to: 'a' | 'b' | 'stack'\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovRegisterToStore\n  (data: {\n    store: StateRef\n    target: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag\n  }): MovStoreToStore\n  (data: {\n    store: StateRef\n    to: 'stack' | 'a' | 'b'\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  (data: {\n    store: StateRef\n    batch?: boolean\n    priority?: BarrierPriorityTag | false\n  }): MovStoreToRegister\n  // (data: {\n  //   from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  //   to?: 'stack' | 'a' | 'b' | 'store'\n  //   store?: StateRef\n  //   target?: StateRef\n  // }): Mov\n} = ({\n  from = STORE,\n  store,\n  target,\n  to = target ? STORE : STACK,\n  batch,\n  priority,\n}: {\n  from?: 'value' | 'store' | 'stack' | 'a' | 'b'\n  to?: 'stack' | 'a' | 'b' | 'store'\n  store?: StateRef\n  target?: StateRef\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n}) => cmd('mov', {from, store, to, target}, priority, batch)\n\nexport const compute = ({\n  fn,\n  batch,\n  priority,\n  safe = false,\n  filter = false,\n  pure = false,\n}: {\n  fn?: (data, scope: {[key: string]}, stack: Stack) => any\n  batch?: boolean\n  priority?: BarrierPriorityTag | false\n  safe?: boolean\n  filter?: boolean\n  pure?: boolean\n}): Compute => cmd('compute', {fn, safe, filter, pure}, priority, batch)\n\nexport const filter = ({\n  fn,\n  pure,\n}: {\n  fn(data, scope: {[key: string]}, stack: Stack)\n  pure?: boolean\n}) => compute({fn, filter: true, pure})\n\nexport const run = ({fn}: {fn(data, scope: {[key: string]}, stack: Stack)}) =>\n  compute({fn, priority: EFFECT})\n\nexport const calc = (\n  fn: (data, scope: {[key: string]}, stack: Stack) => any,\n  filter?: boolean,\n  isEffect?: boolean,\n) => compute({fn, safe: true, filter, priority: isEffect && EFFECT})\n\n/**\n * `read(ref, true, true)`: **reg.stack** with **sampler** batch\n *\n * `read(ref, true, false)`: **reg.stack** without batch\n *\n * `read(ref, false, true)`: **reg.a** with **sampler** batch\n *\n * `read(ref, false, false)`: **reg.a** without batch\n *\n */\nexport const read = (\n  store: StateRef,\n  toStack?: boolean,\n  samplerPriority?: boolean,\n) =>\n  mov({\n    store,\n    to: toStack ? STACK : REG_A,\n    priority: samplerPriority && SAMPLER,\n    batch: true,\n  })\n\nexport const userFnCall = (\n  fn: (data, scope: {[key: string]}, stack: Stack) => any = callStack,\n  isFilter?: boolean,\n) => compute({fn, pure: true, filter: isFilter})\n\nexport const step = {mov, compute, filter, run}\n","import type {StateRef, StateRefOp} from './index.h'\nimport {nextStepID} from './id'\nimport {add} from './collection'\n\nexport const createStateRef = (current?): StateRef => ({\n  id: nextStepID(),\n  current,\n})\nexport const readRef = ({current}: StateRef | {current}) => current\n\nexport const addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  add(ref.before!, op as any)\n}\n","import {Node, NodeUnit} from './index.h'\nimport {getGraph, getOwners, getLinks, getSubscribers, getMeta} from './getter'\nimport {is} from './is'\nimport {removeItem} from './collection'\nimport {CROSSLINK} from './tag'\n\nconst removeFromNode = (currentNode: Node, targetNode: Node) => {\n  removeItem(currentNode.next, targetNode)\n  removeItem(getOwners(currentNode), targetNode)\n  removeItem(getLinks(currentNode), targetNode)\n}\nconst clearNodeNormalized = (\n  targetNode: Node,\n  deep: boolean,\n  isDomainUnit: boolean,\n) => {\n  targetNode.next.length = 0\n  targetNode.seq.length = 0\n  //@ts-expect-error\n  targetNode.scope = null\n  let currentNode\n  let list = getLinks(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (\n      deep ||\n      (isDomainUnit && getMeta(targetNode, 'op') !== 'sample') ||\n      currentNode.family.type === CROSSLINK\n    ) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n  list = getOwners(targetNode)\n  while ((currentNode = list.pop())) {\n    removeFromNode(currentNode, targetNode)\n    if (isDomainUnit && currentNode.family.type === CROSSLINK) {\n      clearNodeNormalized(\n        currentNode,\n        deep,\n        getMeta(currentNode, 'op') !== 'on' && isDomainUnit,\n      )\n    }\n  }\n}\nconst clearMap = (map: Map<any, any> | Set<any>) => map.clear()\nexport const clearNode = (\n  graphite: NodeUnit,\n  {\n    deep,\n  }: {\n    deep?: boolean\n  } = {},\n) => {\n  let isDomainUnit = false\n  //@ts-expect-error\n  if (graphite.ownerSet) graphite.ownerSet.delete(graphite)\n  if (is.store(graphite)) {\n    clearMap(getSubscribers(graphite))\n  } else if (is.domain(graphite)) {\n    isDomainUnit = true\n    const history = graphite.history\n    clearMap(history.events)\n    clearMap(history.effects)\n    clearMap(history.stores)\n    clearMap(history.domains)\n  }\n  clearNodeNormalized(getGraph(graphite), !!deep, isDomainUnit)\n}\n","import type {Subscription, NodeUnit} from './index.h'\nimport {clearNode} from './clearNode'\n\nexport const createSubscription = (node: NodeUnit): Subscription => {\n  const result = () => clearNode(node)\n  result.unsubscribe = result\n  return result\n}\n","import {processArgsToConfig} from './config'\nimport {createNode} from './createNode'\nimport type {Subscription, NodeUnit, Cmd} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assertNodeSet, assertTarget} from './is'\n\nexport const createLinkNode = (\n  parent: NodeUnit | NodeUnit[],\n  child: NodeUnit | NodeUnit[],\n  node?: Array<Cmd | false | void | null>,\n  op?: string,\n  scopeFn?: Function,\n) =>\n  createNode({\n    node,\n    parent,\n    child,\n    scope: {fn: scopeFn},\n    meta: {op},\n    family: {owners: [parent, child], links: child},\n    regional: true,\n  })\nexport const forward = (opts: {\n  from: NodeUnit | NodeUnit[]\n  to: NodeUnit | NodeUnit[]\n  meta?: Record<string, any>\n}): Subscription => {\n  const method = 'forward'\n  const [{from, to}, config] = processArgsToConfig(opts, true)\n  assertNodeSet(from, method, '\"from\"')\n  assertNodeSet(to, method, '\"to\"')\n  assertTarget(method, to, 'to')\n  return createSubscription(\n    createNode({\n      parent: from,\n      child: to,\n      meta: {op: method, config},\n      family: {},\n      regional: true,\n    }),\n  )\n}\n","import {run} from './step'\nimport {callStack} from './caller'\nimport {createNode} from './createNode'\nimport {Subscription, NodeUnit} from './index.h'\nimport {createSubscription} from './subscription'\nimport {assert} from './throw'\nimport {isFunction} from './is'\n\nexport const watchUnit = (\n  unit: NodeUnit,\n  handler: (payload) => any,\n): Subscription => {\n  assert(isFunction(handler), '.watch argument should be a function')\n  return createSubscription(\n    createNode({\n      scope: {fn: handler},\n      node: [run({fn: callStack})],\n      parent: unit,\n      meta: {op: 'watch'},\n      family: {owners: unit},\n      regional: true,\n    }),\n  )\n}\n","import type {DataCarrier} from './unit.h'\nimport type {Cmd} from './index.h'\nimport {is, isFunction, isObject, assertTarget} from './is'\nimport {add, forIn, includes} from './collection'\nimport {addRefOp, createStateRef} from './stateRef'\nimport {createLinkNode} from './forward'\nimport {processArgsToConfig} from './config'\nimport {compute, userFnCall, calc, read} from './step'\nimport {createNode} from './createNode'\nimport {launch, Stack} from './kernel'\nimport {getStoreState} from './getter'\nimport {assert} from './throw'\nimport {createEvent} from './createUnit'\nimport {applyTemplate} from './template'\nimport {createSampling} from './sample'\n\nconst launchCase = (\n  scopeTargets: Record<string, DataCarrier>,\n  field: string,\n  data: any,\n  stack: Stack,\n) => {\n  const target = scopeTargets[field]\n  if (target) {\n    launch({\n      target,\n      params: Array.isArray(target) ? target.map(() => data) : data,\n      defer: true,\n      stack,\n    })\n  }\n}\n\nexport function split(...args) {\n  const METHOD = 'split'\n  let targets: Record<string, DataCarrier>\n  let clock: void | DataCarrier | DataCarrier[]\n  let [[source, match], metadata] = processArgsToConfig(args)\n  const configForm = !match\n  if (configForm) {\n    targets = source.cases\n    match = source.match\n    clock = source.clock\n    source = source.source\n  }\n  const matchIsUnit = is.store(match)\n  const matchIsFunction = !is.unit(match) && isFunction(match)\n  const matchIsShape = !matchIsUnit && !matchIsFunction && isObject(match)\n  if (!targets!) targets = {}\n  if (!configForm) {\n    assert(matchIsShape, 'match should be an object')\n    forIn(\n      match,\n      (_, key) =>\n        (targets[key] = createEvent({\n          derived: true,\n          and: metadata,\n        })),\n    )\n    targets.__ = createEvent({derived: true, and: metadata})\n  } else {\n    forIn(targets, (target, field) =>\n      assertTarget(METHOD, target, `cases.${field}`),\n    )\n  }\n  const owners = new Set(\n    ([] as DataCarrier[]).concat(source, clock || [], Object.values(targets)),\n  )\n  const caseNames = Object.keys(\n    matchIsUnit || matchIsFunction ? targets : match,\n  )\n  let splitterSeq: Array<Cmd | false>\n  if (matchIsUnit || matchIsFunction) {\n    if (matchIsUnit) owners.add(match)\n    splitterSeq = [\n      matchIsUnit && read(getStoreState(match), false, true),\n      compute({\n        safe: matchIsUnit,\n        filter: true,\n        pure: !matchIsUnit,\n        fn(data, scopeTargets, stack) {\n          const value = String(matchIsUnit ? stack.a : match(data))\n          launchCase(\n            scopeTargets,\n            includes(caseNames, value) ? value : '__',\n            data,\n            stack,\n          )\n        },\n      }),\n    ]\n  } else if (matchIsShape) {\n    const lastValues = createStateRef({})\n    lastValues.type = 'shape'\n    const units = [] as string[]\n    let needBarrier: boolean\n    forIn(match, (storeOrFn, key) => {\n      if (is.unit(storeOrFn)) {\n        needBarrier = true\n        add(units, key)\n        owners.add(storeOrFn)\n        const updater = createLinkNode(\n          storeOrFn,\n          [],\n          [read(lastValues), calc((upd, _, {a}) => (a[key] = upd))],\n        )\n        if (is.store(storeOrFn)) {\n          lastValues.current[key] = storeOrFn.getState()\n          const storeRef = getStoreState(storeOrFn)\n          addRefOp(lastValues, {from: storeRef, field: key, type: 'field'})\n          applyTemplate('splitMatchStore', storeRef, updater)\n        }\n      }\n    })\n    if (needBarrier!) {\n      applyTemplate('splitBase', lastValues)\n    }\n    splitterSeq = [\n      needBarrier! && read(lastValues, false, true),\n      userFnCall((data, scopeTargets, stack) => {\n        for (let i = 0; i < caseNames.length; i++) {\n          const caseName = caseNames[i]\n          const caseValue = includes(units, caseName)\n            ? stack.a[caseName]\n            : match[caseName](data)\n          if (caseValue) {\n            launchCase(scopeTargets, caseName, data, stack)\n            return\n          }\n        }\n        launchCase(scopeTargets, '__', data, stack)\n      }, true),\n    ]\n  } else {\n    assert(false, 'expect match to be unit, function or object')\n  }\n  const splitterNode = createNode({\n    meta: {op: METHOD},\n    parent: clock ? [] : source,\n    scope: targets,\n    node: splitterSeq!,\n    family: {owners: Array.from(owners)},\n    regional: true,\n  })\n  if (clock) {\n    createSampling(\n      METHOD,\n      clock,\n      source,\n      null,\n      splitterNode,\n      null,\n      METHOD,\n      metadata,\n      /* non-batched */\n      false,\n      false,\n      false,\n    )\n  }\n  if (!configForm) return targets\n}\n","import {add} from '../collection'\nimport {createDefer} from '../defer'\nimport {is} from '../is'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\nexport function allSettled(\n  start,\n  {scope, params: ctx}: {scope: Scope; params?},\n) {\n  if (!is.unit(start))\n    return Promise.reject(Error('first argument should be unit'))\n  const defer = createDefer()\n  //@ts-expect-error\n  defer.parentFork = forkPage\n  const {fxCount} = scope\n  add(fxCount.scope.defers, defer)\n\n  const launchUnits = [start]\n  const launchParams = [] as Array<{params; req} | null>\n  add(\n    launchParams,\n    is.effect(start)\n      ? {\n          params: ctx,\n          req: {\n            rs(value) {\n              //@ts-expect-error\n              defer.value = {status: 'done', value}\n            },\n            rj(value) {\n              //@ts-expect-error\n              defer.value = {status: 'fail', value}\n            },\n          },\n        }\n      : ctx,\n  )\n  add(launchUnits, fxCount)\n  add(launchParams, null)\n  launch({\n    target: launchUnits,\n    params: launchParams,\n    scope,\n  })\n  return defer.req\n}\n","import type {Domain} from './unit.h'\nimport {combine} from './combine'\nimport {createEffect, onSettled, runFn} from './createEffect'\nimport {applyParentHook} from './createUnit'\nimport {processArgsToConfig} from './config'\nimport {\n  getGraph,\n  getParent,\n  getStoreState,\n  setMeta,\n  getCompositeName,\n} from './getter'\nimport {own} from './own'\nimport {is} from './is'\nimport {read, calc} from './step'\nimport {launch} from './kernel'\nimport {EFFECT} from './tag'\nimport {createName} from './naming'\n\nexport function attach(config) {\n  let injected\n  ;[config, injected] = processArgsToConfig(config, true)\n  let {source, effect, mapParams} = config\n  const attached = createEffect(config, injected)\n  setMeta(attached, 'attached', true)\n  const {runner} = getGraph(attached).scope\n  let runnerSteps\n  const runnerFnStep = calc(\n    (upd, _, stack) => {\n      const {params, req, handler} = upd\n      const anyway = attached.finally\n      const rj = onSettled(params, req, false, anyway, stack)\n      const sourceData = stack.a\n      const isEffectHandler = is.effect(handler)\n      let ok = true\n      let computedParams\n      if (mapParams) {\n        ;[ok, computedParams] = runFn(mapParams, rj, [params, sourceData])\n      } else {\n        computedParams = source && isEffectHandler ? sourceData : params\n      }\n      if (ok) {\n        if (isEffectHandler) {\n          launch({\n            target: handler as any,\n            params: {\n              params: computedParams,\n              req: {rs: onSettled(params, req, true, anyway, stack), rj},\n            },\n            page: stack.page,\n            defer: true,\n          })\n        } else {\n          upd.args = [sourceData, computedParams]\n          return true\n        }\n      }\n    },\n    true,\n    true,\n  )\n  if (source) {\n    let state\n    if (is.store(source)) {\n      state = source\n      own(state, [attached])\n    } else {\n      state = combine(source)\n      own(attached, [state])\n    }\n    runnerSteps = [read(getStoreState(state)), runnerFnStep]\n  } else {\n    runnerSteps = [runnerFnStep]\n  }\n  runner.seq.splice(1, 0, ...runnerSteps)\n  attached.use(effect)\n  const parentDomain: Domain | void = getParent(effect)\n  if (parentDomain) {\n    Object.assign(\n      getCompositeName(attached),\n      createName(attached.shortName, parentDomain),\n    )\n    //@ts-expect-error\n    attached.defaultConfig.parent = parentDomain\n  }\n  applyParentHook(effect, attached, EFFECT)\n  return attached\n}\n","import type {Store, Event} from './unit.h'\nimport {createEvent, applyParentHook} from './createUnit'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {processArgsToConfig} from './config'\n\nexport function createApi(...args: [Store<any>, {[key: string]: Function}]) {\n  let [[store, setters], metadata] = processArgsToConfig(args)\n  const result: Record<string, Event<any>> = {}\n  forIn(setters, (fn, key) => {\n    const event = (result[key] = createEvent(key, {\n      parent: getParent(store),\n      config: metadata,\n    }))\n    store.on(event, fn)\n    applyParentHook(store, event)\n  })\n  return result\n}\n","import type {Domain} from './unit.h'\nimport {own} from './own'\nimport {createNode} from './createNode'\nimport type {Config, NodeUnit} from './index.h'\nimport {\n  createEvent,\n  createStore,\n  createNamedEvent,\n  initUnit,\n} from './createUnit'\nimport {createEffect} from './createEffect'\nimport {createLinkNode} from './forward'\nimport {add, forEach, forIn} from './collection'\nimport {getGraph, getParent} from './getter'\nimport {DOMAIN} from './tag'\nimport {launch} from './kernel'\nimport {calc} from './step'\n\nexport function createDomain(nameOrConfig, maybeConfig?): Domain {\n  const node = createNode({family: {type: DOMAIN}, regional: true})\n\n  const result = {\n    history: {},\n    graphite: node,\n    hooks: {},\n  }\n\n  node.meta = initUnit(DOMAIN, result, nameOrConfig, maybeConfig)\n\n  forIn(\n    {\n      Event: createEvent,\n      Effect: createEffect,\n      Store: createStore,\n      Domain: createDomain,\n    },\n    (factory, tag) => {\n      const lowerCaseTag = tag.toLowerCase()\n\n      const trigger = createNamedEvent(`on${tag}`)\n      result.hooks[lowerCaseTag] = trigger\n\n      const acc = new Set<any>()\n      result.history[`${lowerCaseTag}s`] = acc\n\n      trigger.create = res => {\n        launch(trigger, res)\n        return res\n      }\n      add(\n        getGraph(trigger).seq,\n        calc((upd, _, stack) => {\n          stack.scope = null\n          return upd\n        }),\n      )\n      trigger.watch(data => {\n        own(result, [data])\n        acc.add(data)\n        if (!data.ownerSet) data.ownerSet = acc\n        if (!getParent(data)) data.parent = result\n      })\n      own(result, [trigger])\n\n      result[`onCreate${tag}`] = (hook: (data) => any) => {\n        forEach(acc, hook)\n        return trigger.watch(hook)\n      }\n      result[`create${tag}`] = result[lowerCaseTag] = (\n        nameOrConfig,\n        config?: Config,\n      ) => trigger(factory(nameOrConfig, {parent: result, or: config}))\n    },\n  )\n\n  const parent = getParent(result)\n  if (parent) {\n    forIn(result.hooks, (from: NodeUnit, key) =>\n      createLinkNode(from, parent.hooks[key]),\n    )\n  }\n  return result\n}\n","import {is} from '../is'\nimport {assert} from '../throw'\nimport type {Domain} from '../unit.h'\nimport {normalizeValues} from './util'\nimport {createScope} from './createScope'\n\nexport function fork(\n  domainOrConfig?: Domain | {values?; handlers?},\n  optiionalConfig?: {values?; handlers?},\n) {\n  let config: {values?; handlers?} | void = domainOrConfig as any\n  let domain: Domain\n  if (is.domain(domainOrConfig)) {\n    domain = domainOrConfig\n    config = optiionalConfig\n  }\n\n  const scope = createScope(domain!)\n\n  if (config) {\n    if (config.values) {\n      const valuesSidMap = normalizeValues(config.values, unit =>\n        assert(is.store(unit), 'Values map can contain only stores as keys'),\n      )\n      Object.assign(scope.sidValuesMap, valuesSidMap)\n    }\n    if (config.handlers) {\n      scope.handlers = normalizeValues(config.handlers, unit =>\n        assert(\n          is.effect(unit),\n          `Handlers map can contain only effects as keys`,\n        ),\n      )\n    }\n  }\n  return scope\n}\n","import {getForkPage, getGraph, getMeta, getParent} from '../getter'\nimport {setForkPage, getPageRef, currentPage} from '../kernel'\nimport {createNode} from '../createNode'\nimport {calc, compute} from '../step'\nimport type {Domain, Scope} from '../unit.h'\nimport type {StateRef} from '../index.h'\nimport {forEach} from '../collection'\nimport {DOMAIN, SAMPLER, SCOPE} from '../tag'\n\nexport function createScope(unit?: Domain): Scope {\n  const forkInFlightCounter = createNode({\n    scope: {\n      defers: [],\n      inFlight: 0,\n      fxID: 0,\n    },\n    node: [\n      calc((_, scope, stack) => {\n        if (!getParent(stack)) {\n          scope.fxID += 1\n          return\n        }\n        if (getMeta(getParent(stack).node, 'needFxCounter') === 'dec') {\n          scope.inFlight -= 1\n        } else {\n          scope.inFlight += 1\n          scope.fxID += 1\n        }\n      }),\n      compute({priority: SAMPLER, batch: true}),\n      calc(\n        (_, scope) => {\n          const {defers, fxID} = scope\n          if (scope.inFlight > 0 || defers.length === 0) return\n          Promise.resolve().then(() => {\n            if (scope.fxID !== fxID) return\n            forEach(defers.splice(0, defers.length), defer => {\n              setForkPage(defer.parentFork)\n              defer.rs(defer.value)\n            })\n          })\n        },\n        false,\n        true,\n      ),\n    ],\n  })\n  const page = {} as Record<string, StateRef>\n  const storeChange = createNode({\n    node: [\n      calc((value, __, stack) => {\n        const storeStack = getParent(stack)\n        if (storeStack && getParent(storeStack)) {\n          const storeNode = storeStack.node\n          if (\n            !getMeta(storeNode, 'isCombine') ||\n            getMeta(getParent(storeStack).node, 'op') !== 'combine'\n          ) {\n            const forkPage = getForkPage(stack)!\n            const id = storeNode.scope.state.id\n            const sid = getMeta(storeNode, 'sid')\n            forkPage.sidIdMap[sid] = id\n            forkPage.sidValuesMap[sid] = value\n          }\n        }\n      }),\n    ],\n  })\n  const resultScope: Scope = {\n    cloneOf: unit,\n    reg: page,\n    sidValuesMap: {},\n    sidIdMap: {},\n    getState(store) {\n      if ('current' in store) {\n        return getPageRef(currentPage, resultScope, null, store).current\n      }\n      const node = getGraph(store)\n      return getPageRef(currentPage, resultScope, node, node.scope.state, true)\n        .current\n    },\n    kind: SCOPE,\n    graphite: createNode({\n      family: {\n        type: DOMAIN,\n        links: [forkInFlightCounter, storeChange],\n      },\n      meta: {unit: 'fork'},\n      scope: {forkInFlightCounter},\n    }),\n    additionalLinks: {},\n    handlers: {},\n    fxCount: forkInFlightCounter,\n    storeChange,\n  }\n  return resultScope\n}\n","import {observableSymbol} from './observable'\nimport type {Event} from './unit.h'\nimport {createEvent} from './createUnit'\nimport {assertObject} from './is'\nimport {assert} from './throw'\nimport {createSubscription} from './subscription'\n\nexport function fromObservable<T>(observable): Event<T> {\n  assertObject(observable)\n  const observableItem =\n    observableSymbol in observable ? observable[observableSymbol]() : observable\n  assert(observableItem.subscribe, 'expect observable to have .subscribe')\n  const event = createEvent<T>()\n  const disposer = createSubscription(event)\n  observableItem.subscribe({\n    next: event,\n    error: disposer,\n    complete: disposer,\n  })\n  return event\n}\n","import {processArgsToConfig} from './config'\nimport {validateSampleConfig, createSampling} from './sample'\n\nexport function guard(...args) {\n  let [[source, config], metadata] = processArgsToConfig(args)\n  if (!config) {\n    config = source\n    source = config.source\n  }\n  validateSampleConfig(config, 'guard')\n  return createSampling(\n    'guard',\n    config.clock,\n    source,\n    config.filter,\n    config.target,\n    null,\n    config.name,\n    metadata,\n    !config.greedy,\n    false,\n    true,\n  )\n}\n","import {is, isObject} from '../is'\nimport {assert} from '../throw'\nimport {launch} from '../kernel'\nimport type {Domain, Scope} from '../unit.h'\nimport type {Node} from '../index.h'\nimport {add, includes} from '../collection'\nimport {normalizeValues, traverseStores} from './util'\nimport {getGraph} from '../getter'\n\n/**\n hydrate state on client\n\n const root = createDomain()\n hydrate(root, {\n  values: window.__initialState__\n})\n\n */\nexport function hydrate(domain: Domain | Scope, {values}: {values}) {\n  assert(isObject(values), 'values property should be an object')\n  const normalizedValues = normalizeValues(values)\n  const valuesSidList = Object.getOwnPropertyNames(normalizedValues)\n  const storeNodes: Node[] = []\n  const storeValues = []\n  let forkPage: Scope\n  let traverseTarget: Node\n  let needToAssign: true | void\n  if (is.scope(domain)) {\n    forkPage = domain\n    needToAssign = true\n    assert(forkPage.cloneOf, 'scope should be created from domain')\n    traverseTarget = getGraph(forkPage.cloneOf)\n  } else if (is.domain(domain)) {\n    traverseTarget = getGraph(domain)\n  } else {\n    assert(false, 'first argument of hydrate should be domain or scope')\n  }\n  traverseStores(traverseTarget!, (node, sid) => {\n    // forkPage.sidIdMap[sid] = node.scope.state.id\n    if (includes(valuesSidList, sid)) {\n      add(storeNodes, node)\n      add(storeValues, normalizedValues[sid])\n    }\n  })\n  launch({\n    target: storeNodes,\n    params: storeValues,\n    scope: forkPage!,\n  })\n  if (needToAssign) {\n    Object.assign(forkPage!.sidValuesMap, normalizedValues)\n  }\n}\n","import {createStore} from './createUnit'\nimport {is} from './is'\nimport {forIn} from './collection'\nimport {getParent} from './getter'\nimport {createLinkNode} from './forward'\nimport {deprecate} from './throw'\n\nexport function restore(obj, defaultState, config?) {\n  if (is.store(obj)) {\n    deprecate(false, 'restore($store)')\n    return obj\n  }\n  if (is.event(obj) || is.effect(obj)) {\n    const domain = getParent(obj)\n    const result = createStore(defaultState, {\n      parent: domain,\n      name: obj.shortName,\n      and: config,\n    })\n    createLinkNode(is.effect(obj) ? obj.doneData : obj, result)\n    if (domain) domain.hooks.store(result)\n    return result\n  }\n  const result: Record<string, any> = Array.isArray(obj) ? [] : {}\n  forIn(\n    obj,\n    (value, key) =>\n      (result[key] = is.store(value) ? value : createStore(value, {name: key})),\n  )\n  return result\n}\n","import {createDefer} from '../defer'\nimport {is} from '../is'\nimport {assert} from '../throw'\nimport {launch, forkPage} from '../kernel'\nimport type {Scope} from '../unit.h'\n\n/** bind event to scope */\nexport function scopeBind(unit, {scope}: {scope?: Scope} = {}) {\n  assert(\n    scope || forkPage,\n    'scopeBind cannot be called outside of forked .watch',\n  )\n  const savedForkPage = scope || forkPage!\n  return is.effect(unit)\n    ? params => {\n        const req = createDefer()\n        launch({\n          target: unit,\n          params: {\n            params,\n            req,\n          },\n          scope: savedForkPage,\n        })\n        return req.req\n      }\n    : params => {\n        launch({target: unit, params, scope: savedForkPage})\n        return params\n      }\n}\n","import type {Scope, Store} from '../unit.h'\nimport {forIn, includes} from '../collection'\nimport {assert} from '../throw'\nimport {traverseStores} from './util'\nimport {getGraph, getMeta} from '../getter'\n\n/**\n serialize state on server\n */\nexport function serialize(\n  scope: Scope,\n  config: {ignore?: Array<Store<any>>; onlyChanges?: boolean} = {},\n) {\n  const ignoredStores = config.ignore ? config.ignore.map(({sid}) => sid) : []\n  const result = {} as Record<string, any>\n  forIn(scope.sidValuesMap, (value, sid) => {\n    if (includes(ignoredStores, sid)) return\n    const id = scope.sidIdMap[sid]\n    // if (!scope.changedStores.has(id)) return\n    if (id && id in scope.reg) {\n      result[sid] = scope.reg[id].current\n    } else {\n      result[sid] = value\n    }\n  })\n  if ('onlyChanges' in config && !config.onlyChanges) {\n    assert(scope.cloneOf, 'scope should be created from domain')\n    traverseStores(getGraph(scope.cloneOf), (node, sid) => {\n      if (\n        !(sid in result) &&\n        !includes(ignoredStores, sid) &&\n        !getMeta(node, 'isCombine') &&\n        getMeta(node, 'serialize') !== 'ignore'\n      )\n        result[sid] = scope.getState(node as any)\n    })\n  }\n  return result\n}\n"],"names":["forIn","obj","cb","key","forEach","list","fn","assert","condition","message","Error","withRegion","unit","regionStack","parent","value","template","getMeta","readTemplate","sidRoot","getParent","createNode","node","from","source","to","target","child","scope","meta","family","familyRaw","type","regional","sources","arrifyNodes","links","owners","seq","item","add","result","id","nextNodeID","next","CROSSLINK","link","getOwners","owner","getLinks","own","getValue","launch","payload","upsert","pageForLaunch","currentPage","stackForLaunch","forkPageForLaunch","forkPage","params","defer","page","getForkPage","Array","isArray","i","length","pushFirstHeapItem","getGraph","isRoot","stop","skip","reg","lastStartedState","isWatch","isPure","kernelLoop","deleteMin","idx","stack","hasPageReg","hasScopeReg","local","fail","stepn","step","order","priority","barrierID","fullID","barriers","has","pushHeap","delete","data","STACK","REG_A","VALUE","store","STORE","pageForRef","getPageForRef","initRefInScope","softRead","undefined","readRef","getPageRef","current","pure","computationResult","safe","tryRun","filter","finalValue","nextNode","fxCount","storeChange","additionalLinks","unitObjectName","objOrArr","method","name","comma","is","getCompositeName","fullName","toString","createName","path","shortName","composite","concat","processArgsToConfig","args","singleArgument","rawConfig","assertObject","metadata","or","childConfig","and","unwrappedNestedValue","isObject","nested","applyTemplate","handlers","createEvent","nameOrConfig","maybeConfig","event","deprecate","oldPage","setCurrentPage","create","callCreate","Object","assign","graphite","initUnit","EVENT","watch","watchUnit","map","deriveEvent","MAP","userFnCall","callStack","filterMap","calc","isVoid","prepend","contramapped","createLinkNode","applyParentHook","createStore","defaultState","props","plainState","createStateRef","updates","createNamedEvent","plainStateId","subscribers","Map","stateRef","getState","reachedPage","targetRef","setState","state","reset","units","on","nodeSet","assertNodeSet","trigger","off","getSubscribers","set","createSubscription","updateStore","callARegStack","currentSubscription","get","firstState","config","lastResult","storeState","innerStore","derived","linkNode","callStackAReg","addRefOp","getStoreState","noInit","eventOrFn","subscription","isFunction","updateFilter","defaultConfig","upd","_","b","read","a","mov","sid","setMeta","combine","handler","stores","structStoreShape","shapeReady","noArraySpread","rawHandler","slice","storeCombination","createDefer","req","Promise","rs","rj","catch","err","createEffect","instance","kind","EFFECT","use","runner","getCurrent","anyway","finally","done","named","status","error","doneData","failData","handlerId","getType","scope_","handler_","onResolve","onSettled","onReject","ok","runFn","then","op","fx","savedFork","setForkPage","inFlight","x","pending","amount","merge","validateSampleConfig","atLeastOneFieldExists","sampleConfigFields","field","fieldErrorMessage","traverseStores","root","visit","includes","normalizeValues","values","assertEach","observableSymbol","Symbol","observable","DOMAIN","SCOPE","SAMPLER","BARRIER","SAMPLE","effect","domain","removeItem","pos","indexOf","splice","push","subject","suggestion","console","graph","val","compositeName","idCount","nextUnitID","nextStepID","readSidRoot","ownerUnit","_link","flat","assertNodeSetItem","valueName","reason","assertTarget","targetField","cmd","batch","nextBarrierID","compute","run","isEffect","toStack","samplerPriority","isFilter","ref","before","heap","ret","v","getPriority","r","l","queue","ix","first","last","size","bucket","t","Set","newForkPage","newPage","isGetState","sourceRef","isKernelCall","refsMap","sidValuesMap","sidIdMap","isFresh","needToAssign","flattenConfig","part","removeFromNode","currentNode","targetNode","clearNodeNormalized","deep","isDomainUnit","pop","clearMap","clear","clearNode","ownerSet","history","events","effects","domains","unsubscribe","scopeFn","hookType","hooks","configA","configB","isDomain","unitId","serialize","thru","subscribe","observer","nativeTemplate","mapped","caller","storeRef","reader","needSpread","clone","stateNew","rawShape","storeStateRef","rawShapeReader","c","childRef","defaultShape","sidechain","createSampling","clock","batched","targetMayBeStore","filterRequired","isUpward","sourceIsClock","filterType","clockState","filterNodes","filterRef","hasFilter","syncSourceState","readAndFilter","hasSource","src","isSourceStore","launchCase","scopeTargets","start","ctx","reject","parentFork","defers","launchUnits","launchParams","injected","mapParams","attached","runnerSteps","runnerFnStep","computedParams","sourceData","isEffectHandler","parentDomain","setters","createDomain","Event","Effect","Store","Domain","factory","tag","lowerCaseTag","toLowerCase","acc","res","hook","domainOrConfig","optiionalConfig","forkInFlightCounter","fxID","resolve","__","storeStack","storeNode","resultScope","cloneOf","createScope","valuesSidMap","opts","observableItem","disposer","complete","greedy","traverseTarget","normalizedValues","valuesSidList","getOwnPropertyNames","storeNodes","storeValues","savedForkPage","ignoredStores","ignore","onlyChanges","rawName","targets","METHOD","match","configForm","cases","matchIsUnit","matchIsFunction","matchIsShape","splitterSeq","caseNames","keys","String","lastValues","needBarrier","storeOrFn","updater","caseName","splitterNode","loc"],"mappings":"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"}