"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.debounce = debounce;

var _effector = require("effector");

function debounce({
  source,
  timeout,
  target
}) {
  if (!_effector.is.unit(source)) throw new TypeError('source must be unit from effector');
  if (_effector.is.domain(source, {
    sid: "iu8yzo"
  })) throw new TypeError('source cannot be domain');
  if (typeof timeout !== 'number' || timeout < 0 || !Number.isFinite(timeout)) throw new Error(`timeout must be positive number or zero. Received: "${timeout}"`);
  let rejectPromise;
  let timeoutId;
  const tick = target ?? (0, _effector.createEvent)({
    name: "tick",
    sid: "-xw52dh"
  });
  const timerFx = (0, _effector.createEffect)(parameter => {
    clearTimeout(timeoutId);
    if (rejectPromise) rejectPromise();
    return new Promise((resolve, reject) => {
      rejectPromise = reject;
      timeoutId = setTimeout(resolve, timeout, parameter);
    });
  }, {
    name: "timerFx",
    sid: "m8kfsq"
  });
  (0, _effector.forward)({
    and: {
      from: source,
      to: timerFx
    },
    or: {
      sid: "k4foqk"
    }
  });
  (0, _effector.forward)({
    and: {
      from: timerFx.done.map(({
        result
      }) => result),
      to: tick
    },
    or: {
      sid: "k76npd"
    }
  });
  return tick;
}