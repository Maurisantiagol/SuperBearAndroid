"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interval = interval;

var _effector = require("effector");

function interval({
  timeout,
  start,
  stop,
  leading = false,
  trailing = false
}) {
  const tick = (0, _effector.createEvent)({
    name: "tick",
    sid: "uo9p3s"
  });
  const $isRunning = (0, _effector.createStore)(false, {
    name: "$isRunning",
    sid: "-wxesi8"
  });
  const $timeout = toStoreNumber(timeout);
  const $notRunning = $isRunning.map(running => !running);
  const saveTimeout = (0, _effector.createEvent)({
    name: "saveTimeout",
    sid: "as5clk"
  });
  const $timeoutId = (0, _effector.createStore)(null, {
    name: "$timeoutId",
    sid: "-bh90bo"
  }).on(saveTimeout, (_, id) => id);
  const saveReject = (0, _effector.createEvent)({
    name: "saveReject",
    sid: "-64swis"
  }); // eslint-disable-next-line @typescript-eslint/no-empty-function

  const $rejecter = (0, _effector.createStore)(() => {}, {
    name: "$rejecter",
    sid: "eabbu7"
  }).on(saveReject, (_, rj) => rj);
  const timeoutFx = (0, _effector.createEffect)(timeout => {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(resolve, timeout);
      saveTimeout(timeoutId);
      saveReject(reject);
    });
  }, {
    name: "timeoutFx",
    sid: "7lc3mj"
  });
  const cleanupFx = (0, _effector.attach)({
    and: {
      source: [$timeoutId, $rejecter],
      effect: ([id, rj]) => {
        rj();
        if (id) clearTimeout(id);
      }
    },
    or: {
      name: "cleanupFx",
      sid: "pcn5jq"
    }
  });
  (0, _effector.guard)({
    and: [{
      clock: start,
      source: $timeout,
      filter: $notRunning,
      target: timeoutFx
    }],
    or: {
      sid: "-w5qmwp"
    }
  });

  if (leading) {
    (0, _effector.guard)({
      and: [{
        clock: start,
        filter: $notRunning,
        target: tick
      }],
      or: {
        sid: "-vpslni"
      }
    });
  }

  (0, _effector.sample)({
    and: [{
      clock: start,
      fn: () => true,
      target: $isRunning
    }],
    or: {
      sid: "-vaed34"
    }
  });
  (0, _effector.guard)({
    and: [{
      clock: timeoutFx.done,
      source: $timeout,
      filter: $isRunning,
      target: timeoutFx
    }],
    or: {
      sid: "-v73liy"
    }
  });
  (0, _effector.sample)({
    and: [{
      clock: timeoutFx.done,
      fn: () => {
        /* to be sure, nothing passed to tick */
      },
      target: tick
    }],
    or: {
      sid: "-urpcwu"
    }
  });

  if (stop) {
    if (trailing) {
      (0, _effector.sample)({
        and: [{
          clock: stop,
          target: tick
        }],
        or: {
          sid: "-uanqf7"
        }
      });
    }

    $isRunning.on(stop, () => false);
    (0, _effector.sample)({
      and: [{
        clock: stop,
        target: cleanupFx
      }],
      or: {
        sid: "6lcmyy"
      }
    });
  }

  return {
    tick,
    isRunning: $isRunning
  };
}

function toStoreNumber(value) {
  if (_effector.is.store(value, {
    sid: "6p7767"
  })) return value;

  if (typeof value === 'number') {
    return (0, _effector.createStore)(value, {
      and: {
        name: '$timeout'
      },
      sid: "5hw6se"
    });
  }

  throw new TypeError(`timeout parameter in interval method should be number or Store. "${typeof value}" was passed`);
}