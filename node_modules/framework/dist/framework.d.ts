export { default as loadable } from '@loadable/component';
import { RouteConfig, MatchedRoute } from 'react-router-config';
export { RouteConfig } from 'react-router-config';
import * as effector from 'effector';
import { Event, Domain, Store, Unit } from 'effector';
import * as history from 'history';
import * as React from 'react';

interface HistoryChange {
    pathname: string;
    hash: string;
    search: string;
    action: 'PUSH' | 'POP' | 'REPLACE';
}

declare function createBrowserApplication(config: {
    ready: Event<void>;
    routes: RouteConfig[];
    domain?: Domain;
}): {
    navigation: {
        history: history.History<unknown>;
        historyPush: effector.Effect<string, void, Error>;
        historyPushSearch: effector.Effect<string, void, Error>;
        historyReplace: effector.Effect<string, void, Error>;
        historyChanged: Event<HistoryChange>;
        historyEmitCurrent: Event<void>;
        $redirectTo: effector.Store<string>;
    };
};

interface HatchParams {
    params: Record<string, string>;
    query: Record<string, string>;
}
/**
 * Hatch is like a Gate, but just for models
 */
interface Hatch {
    enter: Event<HatchParams>;
    update: Event<HatchParams>;
    exit: Event<void>;
    $opened: Store<boolean>;
    $params: Store<Record<string, string>>;
    $query: Store<Record<string, string>>;
    $props: Store<HatchParams>;
}
interface Config {
    enter: Event<HatchParams>;
    update: Event<HatchParams>;
    exit: Event<void>;
    domain?: Domain;
}
/**
 * Events here is an input signal, history should call them when route enters, updates, and exits.
 * Stores is derived from this events and holds specific parameters
 * `$opened` holds current state of page, if user visited page but not left, it is `true`
 */
declare function createHatch(config_?: Config | Domain): Hatch;
declare function withHatch<C extends React.ComponentType>(hatch: Hatch, component: C): C;
declare function getHatch<T extends React.ComponentType<any>>(component: T): Hatch | undefined;
declare function lookupHatch<P>(match: MatchedRoute<P>): Hatch | undefined;

declare type KeysOfEffectorApi<API> = {
    [KEY in keyof API]: API[KEY] extends Unit<any> ? KEY : never;
}[keyof API];
declare function contract<Properties extends string, Page extends Record<Properties, unknown>>(config: {
    page: Page;
    model: Pick<Page, KeysOfEffectorApi<Page>>;
}): void;

declare const createPages: (routes: RouteConfig[]) => JSX.Element;

export { Hatch, HatchParams, contract, createBrowserApplication, createHatch, createPages, getHatch, lookupHatch, withHatch };
